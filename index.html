<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æˆ‘æ˜¯äº‘éª¨ç¬› ä½ æ˜¯è°ï¼Ÿ</title>
    <link href="https://fonts.googleapis.com/css2?family=Ma+Shan+Zheng&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Ma Shan Zheng', cursive, sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            color: #333;
            transition: background 0.5s ease;
            overflow: hidden;
        }
        
        /* é¡µé¢å®¹å™¨ */
        .page {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            transition: opacity 0.5s ease;
            overflow: hidden;
        }
        
        /* ç¬¬ä¸€é¡µï¼šå¯¹è¯é¡µé¢ */
        #page1 {
            opacity: 1;
            z-index: 10;
        }
        
        #page1.hidden {
            opacity: 0;
            pointer-events: none;
            z-index: 0;
        }
        
        .container {
            width: 100%;
            max-width: 1200px;
            text-align: center;
        }
        
        .dialogue-container {
            display: flex;
            flex-direction: column;
            gap: 40px;
            margin-bottom: 60px;
        }
        
        .dialogue-box {
            position: relative;
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease;
        }
        
        .dialogue-box:hover {
            transform: translateY(-5px);
        }
        
        .yun-box {
            background: linear-gradient(to right, #a8edea 0%, #fed6e3 100%);
            align-self: flex-start;
            max-width: 60%;
            margin-left: 10%;
        }
        
        .ai-box {
            background: linear-gradient(to right, #d4fc79 0%, #96e6a1 100%);
            align-self: flex-end;
            max-width: 60%;
            margin-right: 10%;
        }
        
        .dialogue-text {
            font-size: 5rem;
            font-weight: bold;
            line-height: 1.2;
        }
        
        .yun-text {
            color: #2d3436;
        }
        
        .ai-text {
            color: #2d3436;
        }
        
        /* è¾“å…¥åŒºåŸŸæ ·å¼ */
        .input-container {
            background: linear-gradient(to right, #fdfcfb 0%, #e2d1c3 100%);
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            max-width: 800px;
            margin: 0 auto;
        }
        
        .input-title {
            font-size: 2.5rem;
            margin-bottom: 30px;
            color: #2c3e50;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.1);
        }
        
        .input-group {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 30px;
        }
        
        .name-input {
            flex: 1;
            max-width: 400px;
            padding: 20px 25px;
            font-size: 2rem;
            font-family: 'Ma Shan Zheng', cursive;
            border: 3px solid #a8edea;
            border-radius: 15px;
            background: white;
            color: #2d3436;
            box-shadow: inset 0 5px 10px rgba(0, 0, 0, 0.05);
            transition: all 0.3s ease;
        }
        
        .name-input:focus {
            outline: none;
            border-color: #96e6a1;
            box-shadow: 0 0 0 4px rgba(150, 230, 161, 0.3), inset 0 5px 10px rgba(0, 0, 0, 0.05);
        }
        
        .submit-btn {
            padding: 20px 40px;
            font-size: 2rem;
            font-family: 'Ma Shan Zheng', cursive;
            background: linear-gradient(to right, #a8edea 0%, #fed6e3 100%);
            border: none;
            border-radius: 15px;
            color: #2d3436;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
        }
        
        .submit-btn:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.15);
        }
        
        .submit-btn:active {
            transform: translateY(0);
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
        }
        
        .error-message {
            color: #e74c3c;
            font-size: 1.8rem;
            margin-top: 15px;
            min-height: 30px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .error-message.show {
            opacity: 1;
        }
        
        /* ç¬¬äºŒé¡µï¼šåå­—å±•ç¤ºé¡µé¢ */
        #page2 {
            opacity: 0;
            pointer-events: none;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
        }
        
        #page2.active {
            opacity: 1;
            pointer-events: all;
        }
        
        .name-display-container {
            text-align: center;
            max-width: 95%;
        }
        
        .name-display {
            font-size: 18rem;
            font-weight: bold;
            color: white;
            min-height: 250px;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            gap: 20px;
        }
        
        .name-char {
            display: inline-block;
        }
        
        /* ç¬¬ä¸‰é¡µï¼šå…ƒæ—¦å¿«ä¹é¡µé¢ */
        #page3 {
            opacity: 0;
            pointer-events: none;
            background: #000;
        }
        
        #page3.active {
            opacity: 1;
            pointer-events: all;
        }
        
        /* çƒŸèŠ±Canvas */
        #fireworksCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        
        /* æ–‡å­—å®¹å™¨ */
        .text-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 2;
            pointer-events: none;
        }
        
        /* ä¿®æ”¹åçš„å…ƒæ—¦å¿«ä¹æ–‡å­—åŒºåŸŸ */
        .greeting-container {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 1200px;
            transition: opacity 1s ease;
            opacity: 0;
            white-space: nowrap; /* æ·»åŠ è¿™ä¸€è¡Œï¼Œç¡®ä¿ä¸æ¢è¡Œ */
        }
        
        .greeting-container.active {
            opacity: 1;
        }
        
        /* æœ‹å‹åå­—æ˜¾ç¤ºåŒºåŸŸ */
        .friend-name {
            font-size: 10vw;
            font-weight: 900;
            color: #ffdd00;
            margin-bottom: 10px;
            line-height: 1.1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 100%;
        }
        
        /* å…ƒæ—¦å¿«ä¹æ–‡å­— - ç¡®ä¿åœ¨ä¸€è¡Œæ˜¾ç¤º */
        .new-year-text {
            font-size: 12vw;
            font-weight: 900;
            color: #ff3333;
            line-height: 1;
            white-space: nowrap; /* ç¡®ä¿ä¸æ¢è¡Œ */
            display: inline-block;
        }
        
        /* æ–°æ·»åŠ çš„ï¼šä¸ªæ€§åŒ–è¯­å¥æ˜¾ç¤ºåŒºåŸŸ - è¿›ä¸€æ­¥æ‰©å¤§æ˜¾ç¤ºæ¡† */
        .statement-display {
            width: 90%;
            max-width: 1200px;
            margin: 20px auto 0; /* å‡å°‘ä¸Šè¾¹è·ï¼Œä¸ºæ›´å¤§çš„æ˜¾ç¤ºæ¡†ç•™å‡ºç©ºé—´ */
            padding: 40px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 20px;
            border: 2px solid rgba(255, 204, 0, 0.3);
            opacity: 0;
            transform: translateY(50px);
            transition: all 1s ease;
            /* å¤§å¹…å¢åŠ æœ€å¤§é«˜åº¦ï¼Œä½¿æ–‡æœ¬æ¡†æ›´é•¿ */
            max-height: 700px; /* ä»600pxå¢åŠ åˆ°700px */
            overflow-y: auto;
            display: none;
            position: relative;
            z-index: 20;
            /* ä¼˜åŒ–ç§»åŠ¨ç«¯æ»šåŠ¨ */
            -webkit-overflow-scrolling: touch;
            /* æ·»åŠ å†…éƒ¨é˜´å½±ï¼Œä½¿æ»šåŠ¨æ›´æ˜æ˜¾ */
            box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.5);
        }
        
        .statement-display.active {
            opacity: 1;
            transform: translateY(0);
            display: block;
            animation: statementAppear 1.5s ease-out forwards;
        }
        
        .statement-content {
            font-size: 2.2rem;
            line-height: 1.8;
            color: #ffdd99;
            text-align: justify;
            text-shadow: 0 0 5px rgba(255, 221, 153, 0.5);
            padding: 20px;
            font-family: 'Ma Shan Zheng', cursive;
            word-wrap: break-word;
            overflow-wrap: break-word;
            white-space: pre-wrap; /* ä¿ç•™æ¢è¡Œç¬¦ä½†å…è®¸è‡ªåŠ¨æ¢è¡Œ */
        }
        
        /* å“åº”å¼è®¾è®¡ - è¿›ä¸€æ­¥ä¼˜åŒ–ç§»åŠ¨ç«¯ */
        @media (max-width: 1200px) {
            .dialogue-text {
                font-size: 3.5rem;
            }
            
            .name-display {
                font-size: 14rem;
            }
            
            .friend-name {
                font-size: 11vw;
            }
            
            .new-year-text {
                font-size: 13vw;
                white-space: nowrap; /* ç¡®ä¿ä¸æ¢è¡Œ */
            }
            
            .statement-content {
                font-size: 1.8rem;
            }
            
            .statement-display {
                max-height: 600px; /* ä»500pxå¢åŠ åˆ°600px */
            }
        }
        
        @media (max-width: 992px) {
            .dialogue-text {
                font-size: 3rem;
            }
            
            .name-display {
                font-size: 12rem;
            }
            
            .friend-name {
                font-size: 12vw;
            }
            
            .new-year-text {
                font-size: 14vw;
                white-space: nowrap; /* ç¡®ä¿ä¸æ¢è¡Œ */
            }
            
            .statement-content {
                font-size: 1.6rem;
                padding: 15px;
            }
            
            .statement-display {
                max-height: 550px; /* ä»450pxå¢åŠ åˆ°550px */
                padding: 30px;
            }
        }
        
        @media (max-width: 768px) {
            .dialogue-box {
                padding: 30px;
            }
            
            .yun-box, .ai-box {
                max-width: 85%;
                margin-left: 5%;
                margin-right: 5%;
            }
            
            .input-container {
                padding: 30px 20px;
            }
            
            .input-title {
                font-size: 2rem;
            }
            
            .input-group {
                flex-direction: column;
                align-items: center;
            }
            
            .name-input, .submit-btn {
                width: 100%;
                max-width: 100%;
                font-size: 1.8rem;
                padding: 18px;
            }
            
            .name-display {
                font-size: 9rem;
                gap: 15px;
            }
            
            /* ç§»åŠ¨ç«¯ä¼˜åŒ–ï¼šç¡®ä¿"å…ƒæ—¦å¿«ä¹ï¼"åœ¨ä¸€è¡Œæ˜¾ç¤º */
            .greeting-container {
                white-space: nowrap;
                overflow: visible;
                padding: 0 10px;
            }
            
            .friend-name {
                font-size: 13vw;
                margin-bottom: 5px;
                white-space: nowrap;
                line-height: 1;
            }
            
            .new-year-text {
                font-size: 15vw;
                line-height: 0.9;
                white-space: nowrap; /* å¼ºåˆ¶ä¸æ¢è¡Œ */
                display: inline;
                word-break: keep-all; /* é˜²æ­¢æ–­å­— */
            }
            
            .statement-display {
                padding: 30px 20px;
                margin-top: 20px; /* è¿›ä¸€æ­¥å‡å°‘ä¸Šè¾¹è· */
                max-height: 500px; /* ä»400pxå¢åŠ åˆ°500pxï¼Œä½¿æ–‡æœ¬æ¡†æ›´é•¿ */
                /* åœ¨ç§»åŠ¨ç«¯å¢åŠ æ›´å¤šå†…è¾¹è· */
                padding: 25px 20px;
            }
            
            .statement-content {
                font-size: 1.5rem;
                padding: 10px;
                line-height: 1.6;
            }
        }
        
        @media (max-width: 576px) {
            .dialogue-text {
                font-size: 2.5rem;
            }
            
            .dialogue-box {
                padding: 20px;
            }
            
            .input-title {
                font-size: 1.8rem;
            }
            
            .name-input, .submit-btn {
                font-size: 1.5rem;
            }
            
            .name-display {
                font-size: 7rem;
                gap: 10px;
                flex-direction: column;
            }
            
            /* è¿›ä¸€æ­¥ä¼˜åŒ–å°å±å¹•ä¸‹çš„æ˜¾ç¤º */
            .greeting-container {
                transform: translate(-50%, -50%) scale(0.9);
                width: 95%;
            }
            
            .friend-name {
                font-size: 15vw;
                margin-bottom: 0;
            }
            
            .new-year-text {
                font-size: 17vw;
                white-space: nowrap;
                letter-spacing: -0.5px; /* ç¨å¾®æ”¶ç´§å­—æ¯é—´è· */
            }
            
            .statement-display {
                padding: 20px 15px;
                margin-top: 15px;
                max-height: 450px; /* ä»350pxå¢åŠ åˆ°450pxï¼Œä½¿æ–‡æœ¬æ¡†æ›´é•¿ */
                /* è°ƒæ•´è¾¹æ¡†å’Œé˜´å½± */
                border-width: 1.5px;
                box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.4);
            }
            
            .statement-content {
                font-size: 1.3rem;
                line-height: 1.6;
            }
        }
        
        @media (max-width: 480px) {
            .name-display {
                font-size: 5rem;
            }
            
            /* ä¼˜åŒ–è¶…å°å±å¹•æ˜¾ç¤º */
            .greeting-container {
                transform: translate(-50%, -50%) scale(0.85);
            }
            
            .friend-name {
                font-size: 16vw;
            }
            
            .new-year-text {
                font-size: 18vw;
                white-space: nowrap;
                letter-spacing: -1px;
            }
            
            .statement-display {
                padding: 15px 10px;
                max-height: 400px; /* ä»300pxå¢åŠ åˆ°400pxï¼Œä½¿æ–‡æœ¬æ¡†æ›´é•¿ */
                margin-top: 10px;
                border-radius: 15px; /* ç¨å¾®å‡å°åœ†è§’ */
            }
            
            .statement-content {
                font-size: 1.2rem;
                line-height: 1.5;
                padding: 8px;
            }
        }
        
        @media (max-width: 380px) {
            .friend-name {
                font-size: 17vw;
            }
            
            .new-year-text {
                font-size: 19vw;
                white-space: nowrap;
            }
            
            .greeting-container {
                padding: 0 5px;
                transform: translate(-50%, -50%) scale(0.8);
            }
            
            .statement-display {
                max-height: 380px; /* ä»280pxå¢åŠ åˆ°380pxï¼Œä½¿æ–‡æœ¬æ¡†æ›´é•¿ */
                padding: 12px 8px;
                margin-top: 8px;
                border-radius: 12px;
            }
            
            .statement-content {
                font-size: 1.1rem;
                line-height: 1.4;
            }
        }
        
        @media (max-width: 320px) {
            /* é’ˆå¯¹æœ€å°å±å¹•çš„ä¼˜åŒ– */
            .new-year-text {
                font-size: 20vw;
                white-space: nowrap;
            }
            
            .greeting-container {
                transform: translate(-50%, -50%) scale(0.75);
            }
            
            .statement-display {
                max-height: 350px; /* ä»250pxå¢åŠ åˆ°350pxï¼Œä½¿æ–‡æœ¬æ¡†æ›´é•¿ */
                padding: 10px 6px;
                border-radius: 10px;
            }
            
            .statement-content {
                font-size: 1rem;
                line-height: 1.4;
                padding: 5px;
            }
        }
        
        @media (max-height: 600px) {
            /* é’ˆå¯¹é«˜åº¦è¾ƒå°çš„å±å¹•è¿›è¡Œç‰¹æ®Šä¼˜åŒ– */
            .statement-display {
                max-height: 300px; /* åœ¨é«˜åº¦æœ‰é™çš„å±å¹•ä¸Šå‡å°‘æœ€å¤§é«˜åº¦ */
                margin-top: 5px;
            }
            
            .greeting-container {
                transform: translate(-50%, -50%) scale(0.7);
            }
        }
        
        @media (max-height: 400px) {
            /* é’ˆå¯¹é«˜åº¦éå¸¸å°çš„å±å¹•è¿›è¡Œç‰¹æ®Šä¼˜åŒ– */
            .statement-display {
                max-height: 200px;
                padding: 8px 5px;
            }
            
            .statement-content {
                font-size: 0.9rem;
                line-height: 1.3;
            }
            
            .greeting-container {
                transform: translate(-50%, -50%) scale(0.6);
            }
        }
        
        /* åŠ¨ç”»æ•ˆæœ */
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        @keyframes statementAppear {
            0% {
                opacity: 0;
                transform: translateY(50px) scale(0.9);
            }
            50% {
                opacity: 0.7;
                transform: translateY(-10px) scale(1.05);
            }
            100% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }
        
        .yun-box {
            animation: fadeInUp 1s ease-out 0.3s both;
        }
        
        .ai-box {
            animation: fadeInUp 1s ease-out 1s both;
        }
        
        .input-container {
            animation: fadeInUp 1s ease-out 1.5s both;
        }
        
        .pulse {
            display: inline-block;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        /* ç¬¬ä¸€é˜¶æ®µï¼šåå­—å­—ç¬¦æ”¾å¤§æ˜¾ç¤ºåŠ¨ç”» */
        .scale-up-char {
            opacity: 0;
            transform: scale(3);
            animation: scaleDownChar 1s ease-out forwards;
        }
        
        @keyframes scaleDownChar {
            to {
                opacity: 1;
                transform: scale(1);
            }
        }
        
        /* ç¬¬äºŒé˜¶æ®µï¼šåå­—ä¸‰ç§ç‰¹æ•ˆçš„CSSå®šä¹‰ */
        .gradient-effect {
            background: linear-gradient(90deg, #ff9a9e, #fad0c4, #fad0c4, #a18cd1);
            background-size: 300% 100%;
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            animation: gradientMove 4s infinite alternate;
        }
        
        @keyframes gradientMove {
            0% { background-position: 0% 50%; }
            100% { background-position: 100% 50%; }
        }
        
        .bounce-effect {
            color: #ffdd59;
            animation: bounceChar 1.5s ease infinite;
        }
        
        @keyframes bounceChar {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-40px); }
        }
        
        .rainbow-effect {
            animation: rainbowColor 3s infinite;
        }
        
        @keyframes rainbowColor {
            0% { color: #ff3838; }
            20% { color: #ff9f1a; }
            40% { color: #fff200; }
            60% { color: #32ff7e; }
            80% { color: #18dcff; }
            100% { color: #7d5fff; }
        }
        
        /* æ•´ä½“ç‰¹æ•ˆåº”ç”¨åŠ¨ç”» */
        .whole-effect-apply {
            animation: wholeEffectApply 0.8s ease-out forwards;
        }
        
        @keyframes wholeEffectApply {
            0% { 
                opacity: 0;
                transform: scale(0.5);
            }
            50% { 
                opacity: 1;
                transform: scale(1.2);
            }
            100% { 
                opacity: 1;
                transform: scale(1);
            }
        }
        
        /* å…ƒæ—¦å¿«ä¹æ–‡å­—æ¶ˆå¤±åŠ¨ç”» */
        .fade-out {
            animation: fadeOut 1s ease-out forwards;
        }
        
        @keyframes fadeOut {
            0% {
                opacity: 1;
                transform: scale(1);
            }
            100% {
                opacity: 0;
                transform: scale(0.5);
            }
        }
    </style>
</head>
<body> 
    <!-- ç¬¬ä¸€é¡µï¼šå¯¹è¯é¡µé¢ -->
    <div id="page1" class="page">
        <div class="container">
            <div class="dialogue-container">
                <div class="dialogue-box yun-box">
                    <div class="dialogue-text yun-text">æˆ‘æ˜¯äº‘éª¨ç¬›</div>
                </div>
                
                <div class="dialogue-box ai-box">
                    <div class="dialogue-text ai-text pulse">ä½ æ˜¯è°ï¼Ÿ</div>
                </div>
            </div>
            
            <div class="input-container">
                <h2 class="input-title">è¯·è¾“å…¥ä½ çš„åå­—ï¼š</h2>
                
                <div class="input-group">
                    <input type="text" class="name-input" id="nameInput" placeholder="è¯·è¾“å…¥ä½ çš„åå­—" maxlength="10">
                    <button class="submit-btn" id="submitBtn">
                        æäº¤
                    </button>
                </div>
                
                <div class="error-message" id="errorMessage">
                    è¯·è¾“å…¥æœ‰æ•ˆçš„åå­—
                </div>
            </div>
        </div>
    </div>
    
    <!-- ç¬¬äºŒé¡µï¼šåå­—å±•ç¤ºé¡µé¢ -->
    <div id="page2" class="page">
        <div class="name-display-container">
            <div class="name-display" id="nameDisplay">
                <!-- åå­—å°†åœ¨è¿™é‡Œæ˜¾ç¤º -->
            </div>
        </div>
    </div>
    
    <!-- ç¬¬ä¸‰é¡µï¼šçƒŸèŠ±å’Œå…ƒæ—¦å¿«ä¹é¡µé¢ -->
    <div id="page3" class="page">
        <canvas id="fireworksCanvas"></canvas>
        <div class="text-container">
            <!-- ä¿®æ”¹åçš„å…ƒæ—¦å¿«ä¹é—®å€™åŒºåŸŸ -->
            <div class="greeting-container" id="greetingContainer">
                <div class="friend-name" id="friendName"></div>
                <div class="new-year-text" id="newYearText">å…ƒæ—¦å¿«ä¹ï¼</div>
            </div>
            
            <div class="statement-display" id="statementDisplay">
                <div class="statement-content" id="statementContent">
                    <!-- ä¸ªæ€§åŒ–è¯­å¥å°†åœ¨è¿™é‡Œæ˜¾ç¤º -->
                </div>
            </div>
        </div>
        <!-- éŸ³ä¹æ’­æ”¾å™¨ -->
        <audio id="bgMusic" loop preload="auto"></audio>

        <script>
// ä½¿ç”¨sessionStorageç¡®ä¿æ¯ä¸ªæµè§ˆå™¨ä¼šè¯åªåˆå§‹åŒ–ä¸€æ¬¡
        if (!sessionStorage.getItem('music_initialized')) {
            console.log('ğŸ”„ é¦–æ¬¡åˆå§‹åŒ–éŸ³ä¹');
    
            const audio = document.getElementById('bgMusic');
    
            fetch('music-config.json')
               .then(response => response.json())
               .then(config => {
                  audio.src = config.musicUrl;
                  audio.autoplay = config.autoplay;
                  audio.loop = config.loop;
            
            // æ ‡è®°ä¸ºå·²åˆå§‹åŒ–ï¼ˆè¿™ä¸ªä¼šè¯ä¸­ä¸å†åˆå§‹åŒ–ï¼‰
                  sessionStorage.setItem('music_initialized', 'true');
            
            // ç›‘å¬é¡µé¢å¸è½½ï¼Œæ¸…é™¤æ ‡è®°ï¼ˆå¯é€‰ï¼‰
                  window.addEventListener('beforeunload', () => {
                     sessionStorage.removeItem('music_initialized');
                  });
               })
               .catch(error => {
                  console.error('åŠ è½½å¤±è´¥:', error);
                  audio.src = 'https://music.163.com/song/media/outer/url?id=1413464902.mp3';
                  audio.autoplay = true;
                  audio.loop = true;
                  sessionStorage.setItem('music_initialized', 'true');
               });
        } else {
           console.log('â­ï¸ éŸ³ä¹å·²åœ¨æ­¤ä¼šè¯ä¸­åˆå§‹åŒ–è¿‡ï¼Œè·³è¿‡');
        }

        
       
        
        document.addEventListener('DOMContentLoaded', function() {
            // é¡µé¢å…ƒç´ 
            const page1 = document.getElementById('page1');
            const page2 = document.getElementById('page2');
            const page3 = document.getElementById('page3');
            
            // ç¬¬ä¸€é¡µå…ƒç´ 
            const nameInput = document.getElementById('nameInput');
            const submitBtn = document.getElementById('submitBtn');
            const errorMessage = document.getElementById('errorMessage');
            
            // ç¬¬äºŒé¡µå…ƒç´ 
            const nameDisplay = document.getElementById('nameDisplay');
            
            // ç¬¬ä¸‰é¡µå…ƒç´ 
            const greetingContainer = document.getElementById('greetingContainer');
            const friendName = document.getElementById('friendName');
            const newYearText = document.getElementById('newYearText');
            const statementDisplay = document.getElementById('statementDisplay');
            const statementContent = document.getElementById('statementContent');
            const bgMusic = document.getElementById('bgMusic');
            
            // çŠ¶æ€å˜é‡
            let currentName = '';
            let musicPlayed = false;
            
            // ä¸‰ç§ç‰¹æ•ˆç±»å‹
            const effects = [
                { name: 'æ¸å˜è‰²å½©', class: 'gradient-effect' },
                { name: 'å¼¹è·³æ•ˆæœ', class: 'bounce-effect' },
                { name: 'å½©è™¹æ•ˆæœ', class: 'rainbow-effect' }
            ];
            
            // é€šç”¨ç¥ç¦è¯­
            const genericGreeting = "å…ƒæ—¦å¿«ä¹ï¼æ„¿æ–°å¹´ä¸ºä½ å¸¦æ¥æ— å°½çš„å–œæ‚¦ä¸æˆåŠŸï¼Œæ„¿ä½ çš„æ¯ä¸€å¤©éƒ½å……æ»¡é˜³å…‰ä¸æ¬¢ç¬‘ï¼";
            
            // å§“åä¸å¯¹åº”è¯­å¥çš„æ•°æ®
            const statementsData = {
                "è´ºä¸¹ç²": "ä¸Šå…ƒèŠ‚å¿«ä¹!",
                "å‘¨æ•æ¯…": "å…ƒè¾°å¯ç‘ï¼Œå²åºæ›´æ–°ã€‚å¾å„¿å¦‚å…‰å¤´å¼ºï¼Œå½“æŠ¤æ—å®ˆæ­£ï¼›ä¼¼é’æ¾ï¼Œé¡»å‚²é›ªè€Œç«‹ã€‚è‹¥æ•ˆè¾¾æ‘©ï¼Œå¿…è¸¢äº‘ç ´å£ï¼Œå‹‡è€…æ— ç•ï¼çˆ¶æœ›æ±ä»¥ã€Œå·§æ€ç ´å±€ã€ä¸ºæ¥«ï¼Œä»¥ã€ŒçœŸè¨€Â·å¿ƒç»ã€ä¸ºå¸†ï¼Œæ–°å²å®‰åº·ï¼Œä¼æœ¨æˆæ—ï¼Œæ­¥å±¥é“¿é”µï¼Œå‹‡å¤ºã€Œæ£®æ—å‹‹ç« ã€ï¼Œåéœ‡ã€Œç‹—ç†Šå²­ã€ï¼›æ›´æœŸå¦‚é‡‘è²è¸æµªï¼Œä¼¼ç‹®èˆéœ‡å³¡è°·ï¼Œç»ˆæˆã€Œå¤©é€‰ä¹‹äººã€ï¼Œç‹è€…åŠ å†•ï¼",
                "å¾å®‡èˆª": "æ–°å…ƒå¯ï¼Œé˜¿ç¦»ä¼èˆæ˜ æµå…‰ï¼›å²åºè½¬ï¼ŒèŠ±ä¿¡é£æºå°‘å¹´ç‹‚ã€‚æ„¿å›å¦‚çº¢å¶ç¿©è·¹ç ´éœœå¯’ï¼Œä¼¼çº¸é¸¢æ‰¶æ‘‡å…¥äº‘é•¿ã€‚ä»¥ã€ŒèŠ³åã€ä¸ºç¬”ç»˜å±±æ²³ï¼Œä»¥ã€Œåˆå¿ƒã€ä¸ºé”šå®šæ˜ŸèŠ’ã€‚å…ƒæ—¦å®‰åº·ï¼Œä¸”çœ‹å³¡è°·èŠ±å¼€å¤„ï¼Œå°½æ˜¯å‡Œäº‘å¿—æœªå¤®ï¼",
                "ç‹ç¿”": "ç»´å…¬å…ƒäºŒã€‡äºŒXå¹´å…ƒæ—¥ï¼Œè°¨ç¥ç‹ç¿”å›æ›°ï¼š\nå…ƒè¾°è‚‡å¯ï¼Œç‘æ°”ç›ˆå¯°ã€‚å€¼æ­¤æ–°å²ï¼Œæ„¿å›å¦‚æœé˜³åˆå‡ï¼Œè¾‰å…‰æ—¥æ–°ï¼›ä¼¼é²²é¹æŒ¯ç¿¼ï¼Œå¿—å‡Œéœ„æ±‰ã€‚æ˜”å¹´ç ¥æŸ±ä¸­æµï¼Œåè°‹å…‹è‰°ï¼›ä»Šå²ç ºæˆˆç§£é©¬ï¼Œå†æ‹“å®å›¾ã€‚ä¸‰æ±Ÿæ±‡æµï¼Œä»¥æˆå…¶åŠ¿ï¼›ä¼—å¿—æˆåŸï¼Œä»¥å°±å…¶åŠŸã€‚æ„¿å›æ€€ç‘¾æ¡ç‘œï¼Œå¾·æ‰å¹¶ç ºï¼›ç‡æˆ‘åŒä»ï¼Œåå¥‘å¦‚ç£ã€‚æˆ˜æœ¯ç²¾ç ”ï¼Œè‹¥æ£‹å±€è¿ç­¹ï¼›ååŒæ— é—´ï¼Œä¼¼æˆ˜é˜µåˆä¸€ã€‚ä½¿ä¸‰è§’æ´²ä¹‹åï¼Œå¦‚åŒ—æ–—æ‚¬å¤©ï¼ŒæŒ‡å¼•æ–¹é’ï¼›å¦‚æˆ˜æ——çŒçŒï¼Œå¨éœ‡å…«è’ã€‚",
                "å‘¨æ—­": "å…ƒæ—¥å¯æ–°ï¼Œç‘éœ­ç›ˆé—¨ã€‚\nè´ºå‘¨æ—­å›ï¼š  \næ˜”å²æ— ç•ï¼Œå¥‘ç»“è‹±é­‚ï¼›  \nä»Šå²ç ºé”‹ï¼Œå†æˆ˜ä¹¾å¤ã€‚  \næˆ˜æœ¯å¦‚æ¸Šï¼Œè«æµ‹æ·±æµ…ï¼›  \nå‹‡æ¯…ä¼¼ç«ï¼Œç„šå°½è†æ£˜ã€‚  \næ„¿å›æ€€ç’§å…¶å¾·ï¼Œç‡ä¼—å¦‚é¾™ï¼›  \nä½¿å¥‘çº¦ä¹‹åï¼Œè€€è‹¥è¾°æ˜Ÿã€‚  \næ–°å²å®‰åº·ï¼Œè¯¸äº‹é¡ºé‚ï¼›  \né¹ç¨‹ä¸‡é‡Œï¼Œå…±èµ´è£å…‰ï¼",
                "éƒ½ä¿Šç¦": "éƒ½ä¿Šç¦å¿ï¼Œå…ƒæ—¦å®‰åº·ï¼æ„¿ä¸¤æƒ…ç¼±ç»»ï¼Œæœæœæš®æš®ï¼Œç›¸æ¿¡ä»¥æ²«ï¼Œå²å²å¸¸ç›¸ä¼´ï¼Œç”œèœœæ°¸ç»µé•¿ã€‚",
                "åˆ˜å­å±±": "å…ƒæ—¥è´ºå­å±±å…„ï¼š\nå²å¯æ–°å…ƒï¼Œæ„¿å›å¦‚èŠå…°æ¸…é›…ï¼Œæ‰å­¦æ—¥è¿›ï¼›ä¼¼é’æ¾å‡Œäº‘ï¼Œå¿—æ°”é•¿é’ã€‚å­¦ä¸šç²¾ï¼Œä½“åº·å¥ï¼Œæƒ…è°Šé•¿ï¼Œå…±èµ´é”¦ç¨‹ï¼",
                "ä¸ç‘ç»µ": "ç¥ä¸ç‘ç»µä¸çœ·ä¾£ï¼š\nå²å¯æ–°å…ƒï¼Œæ„¿å¿ä¸å›ï¼Œè‹¥è²åŒæ± ï¼Œä¸è¯­è€Œé¦™ï¼›ä¼¼äº‘å…±å¤©ï¼Œæ— è¨€è€Œè¿œã€‚æœæš®ä¹‹é—´ï¼Œå¿ƒæ‰‹ç›¸ç‰µï¼›é£é›¨ä¹‹é™…ï¼Œæƒ…æ„è‡ªæš–ã€‚æ–°å²å®‰å®ï¼Œæ—§ç¼˜æ„ˆæŸ”ï¼›æ„¿æ­¤æƒ…å¦‚æœˆï¼Œå¸¸åœ†ä¸ç¼ºï¼›æ­¤ç”Ÿå¦‚è¯—ï¼Œç»†æ°´é•¿æµã€‚"
            };
            
            // çƒŸèŠ±ç³»ç»Ÿç›¸å…³å˜é‡
            let fireworksSystem = null;
            let fireworksAnimationId = null;
            let isAutoFiring = false;
            let autoFireInterval = null;
            
            // éŸ³ä¹æ’­æ”¾æ§åˆ¶
            function playBackgroundMusic() {
                if (musicPlayed) return;
                
                try {
                    bgMusic.volume = 0.3; // è®¾ç½®åˆé€‚çš„éŸ³é‡
                    bgMusic.currentTime = 0; // ä»å¤´å¼€å§‹æ’­æ”¾
                    
                    // å°è¯•æ’­æ”¾éŸ³ä¹
                    const playPromise = bgMusic.play();
                    
                    if (playPromise !== undefined) {
                        playPromise.then(() => {
                            // æ’­æ”¾æˆåŠŸ
                            musicPlayed = true;
                            console.log("éŸ³ä¹æ’­æ”¾æˆåŠŸ");
                        }).catch(error => {
                            console.log("è‡ªåŠ¨æ’­æ”¾è¢«é˜»æ­¢ï¼Œéœ€è¦ç”¨æˆ·äº¤äº’:", error);
                            
                            // æ·»åŠ é¡µé¢ç‚¹å‡»äº‹ä»¶æ¥é‡æ–°å°è¯•æ’­æ”¾
                            const playOnClick = function() {
                                bgMusic.play().then(() => {
                                    musicPlayed = true;
                                    console.log("éŸ³ä¹ç‚¹å‡»åæ’­æ”¾æˆåŠŸ");
                                    document.removeEventListener('click', playOnClick);
                                    document.removeEventListener('touchstart', playOnClick);
                                }).catch(e => {
                                    console.log("ç‚¹å‡»åæ’­æ”¾ä»ç„¶å¤±è´¥:", e);
                                });
                            };
                            
                            document.addEventListener('click', playOnClick);
                            document.addEventListener('touchstart', playOnClick);
                        });
                    }
                } catch (error) {
                    console.error("æ’­æ”¾éŸ³ä¹å¤±è´¥:", error);
                }
            }
            
            // æå‰é¢„åŠ è½½éŸ³ä¹ï¼ˆåœ¨ç”¨æˆ·äº¤äº’æ—¶ï¼‰
            function preloadMusic() {
                try {
                    bgMusic.load();
                    console.log("éŸ³ä¹é¢„åŠ è½½å®Œæˆ");
                } catch (error) {
                    console.log("éŸ³ä¹é¢„åŠ è½½å¤±è´¥:", error);
                }
            }
            
            // æäº¤åå­—å‡½æ•°
            function submitName() {
                const name = nameInput.value.trim();
                
                // æ£€æŸ¥è¾“å…¥æ˜¯å¦ä¸ºç©º
                if (name === '') {
                    // æ˜¾ç¤ºé”™è¯¯æç¤º
                    errorMessage.classList.add('show');
                    
                    // 3ç§’åéšè—é”™è¯¯æç¤º
                    setTimeout(() => {
                        errorMessage.classList.remove('show');
                    }, 3000);
                    
                    return;
                }
                
                // éšè—é”™è¯¯æç¤ºï¼ˆå¦‚æœæœ‰ï¼‰
                errorMessage.classList.remove('show');
                
                // ä¿å­˜åå­—
                currentName = name;
                
                // é¢„åŠ è½½éŸ³ä¹ï¼ˆåœ¨ç”¨æˆ·äº¤äº’æ—¶ï¼‰
                preloadMusic();
                
                // åˆ‡æ¢åˆ°åå­—å±•ç¤ºé¡µé¢
                showPage2();
            }
            
            // æ˜¾ç¤ºç¬¬äºŒé¡µï¼ˆåå­—å±•ç¤ºé¡µé¢ï¼‰
            function showPage2() {
                // éšè—ç¬¬ä¸€é¡µ
                page1.classList.add('hidden');
                
                // æ˜¾ç¤ºç¬¬äºŒé¡µ
                setTimeout(() => {
                    page2.classList.add('active');
                    
                    // å¼€å§‹åå­—å±•ç¤ºåŠ¨ç”»
                    showNameDisplay();
                }, 500);
            }
            
            // æ˜¾ç¤ºåå­—å±•ç¤ºåŠ¨ç”»
            function showNameDisplay() {
                // éšæœºé€‰æ‹©ä¸€ç§ç‰¹æ•ˆ
                const randomEffect = effects[Math.floor(Math.random() * effects.length)];
                
                // æ¸…ç©ºåå­—æ˜¾ç¤ºåŒºåŸŸ
                nameDisplay.innerHTML = '';
                
                // ç¬¬ä¸€é˜¶æ®µï¼šé€ä¸ªå­—ç¬¦æ”¾å¤§æ˜¾ç¤º
                const chars = currentName.split('');
                chars.forEach((char, index) => {
                    const charSpan = document.createElement('span');
                    charSpan.className = 'name-char scale-up-char';
                    charSpan.textContent = char;
                    
                    // è®¾ç½®æ¯ä¸ªå­—ç¬¦çš„å»¶è¿Ÿï¼Œé—´éš”1ç§’
                    charSpan.style.animationDelay = `${index * 1}s`;
                    
                    nameDisplay.appendChild(charSpan);
                });
                
                // è®¡ç®—ç¬¬ä¸€é˜¶æ®µå®Œæˆæ—¶é—´ï¼ˆæ‰€æœ‰å­—ç¬¦æ˜¾ç¤ºå®Œæˆåï¼‰
                const firstStageCompleteTime = chars.length * 1000 + 500;
                
                // ç¬¬ä¸€é˜¶æ®µå®Œæˆåï¼Œå¼€å§‹ç¬¬äºŒé˜¶æ®µ
                setTimeout(() => {
                    // ç§»é™¤ç¬¬ä¸€é˜¶æ®µåŠ¨ç”»ç±»
                    const charElements = nameDisplay.querySelectorAll('.name-char');
                    charElements.forEach(charElement => {
                        charElement.classList.remove('scale-up-char');
                        // æ¸…é™¤åŠ¨ç”»å»¶è¿Ÿ
                        charElement.style.animationDelay = '';
                        
                        // æ·»åŠ æ•´ä½“ç‰¹æ•ˆåº”ç”¨åŠ¨ç”»
                        charElement.classList.add('whole-effect-apply');
                    });
                    
                    // çŸ­æš‚å»¶è¿Ÿååº”ç”¨éšæœºç‰¹æ•ˆ
                    setTimeout(() => {
                        // ç§»é™¤æ•´ä½“ç‰¹æ•ˆåº”ç”¨åŠ¨ç”»
                        charElements.forEach(charElement => {
                            charElement.classList.remove('whole-effect-apply');
                            // æ·»åŠ éšæœºç‰¹æ•ˆç±»
                            charElement.classList.add(randomEffect.class);
                        });
                        
                        // ç‰¹æ•ˆæ˜¾ç¤º2ç§’åï¼Œåœé¡¿1ç§’ï¼Œç„¶ååˆ‡æ¢åˆ°å…ƒæ—¦å¿«ä¹é¡µé¢
                        setTimeout(() => {
                            // éšè—ç¬¬äºŒé¡µ
                            page2.classList.remove('active');
                            
                            // æ˜¾ç¤ºç¬¬ä¸‰é¡µ
                            setTimeout(() => {
                                showPage3();
                            }, 1000); // åœé¡¿1ç§’
                        }, 2000); // ç‰¹æ•ˆæ˜¾ç¤º2ç§’
                        
                    }, 800); // ç­‰å¾…æ•´ä½“ç‰¹æ•ˆåº”ç”¨åŠ¨ç”»å®Œæˆ
                    
                }, firstStageCompleteTime);
            }
            
            // æ˜¾ç¤ºç¬¬ä¸‰é¡µï¼ˆçƒŸèŠ±å’Œå…ƒæ—¦å¿«ä¹é¡µé¢ï¼‰
            function showPage3() {
                page3.classList.add('active');
                
                // æ’­æ”¾èƒŒæ™¯éŸ³ä¹
                setTimeout(() => {
                    playBackgroundMusic();
                }, 500);
                
                // å¼€å§‹çƒŸèŠ±ç³»ç»Ÿ
                initFireworksSystem();
                
                // å¼€å§‹å…ƒæ—¦å¿«ä¹åŠ¨ç”»
                showNewYearGreeting();
            }
            
            // æ˜¾ç¤ºå…ƒæ—¦å¿«ä¹åŠ¨ç”»
            function showNewYearGreeting() {
                // æ¸…ç©ºæ˜¾ç¤ºåŒºåŸŸ
                friendName.textContent = '';
                greetingContainer.classList.remove('active');
                statementContent.innerHTML = '';
                statementDisplay.classList.remove('active');
                
                // æ˜¾ç¤ºæœ‹å‹çš„åå­—
                if (currentName && currentName.trim() !== '') {
                    friendName.textContent = currentName ;
                } else {
                    friendName.textContent = 'æœ‹å‹';
                }
                
                // æ˜¾ç¤ºé—®å€™åŒºåŸŸ
                greetingContainer.classList.add('active');
                
                // å…ƒæ—¦å¿«ä¹åŠ¨ç”»å®Œæˆå2ç§’ï¼Œå¼€å§‹æ˜¾ç¤ºä¸ªæ€§åŒ–è¯­å¥æˆ–é€šç”¨ç¥ç¦è¯­
                setTimeout(() => {
                    // æ·»åŠ å…ƒæ—¦å¿«ä¹æ–‡å­—æ¶ˆå¤±åŠ¨ç”»
                    greetingContainer.classList.add('fade-out');
                    
                    // 1ç§’åéšè—å…ƒæ—¦å¿«ä¹æ–‡å­—ï¼Œæ˜¾ç¤ºä¸ªæ€§åŒ–è¯­å¥æˆ–é€šç”¨ç¥ç¦è¯­
                    setTimeout(() => {
                        // æ˜¾ç¤ºç¥ç¦è¯­ï¼ˆä¸ªæ€§åŒ–æˆ–é€šç”¨ï¼‰
                        showGreetingStatement();
                    }, 1000);
                }, 5000); // æ˜¾ç¤º5ç§’å
            }
            
            // æ˜¾ç¤ºç¥ç¦è¯­
            function showGreetingStatement() {
                // æŸ¥æ‰¾å¯¹åº”åå­—çš„è¯­å¥
                let statement = statementsData[currentName];
                
                // å¦‚æœæ²¡æœ‰æ‰¾åˆ°å¯¹åº”è¯­å¥ï¼Œåˆ™ä½¿ç”¨é€šç”¨ç¥ç¦è¯­
                if (!statement) {
                    statement = genericGreeting;
                }
                
                // å°†è¯­å¥æ˜¾ç¤ºåœ¨è¯­å¥åŒºåŸŸ
                statementContent.innerHTML = '';
                
                // å°†è¯­å¥æŒ‰æ¢è¡Œåˆ†å‰²å¹¶æ·»åŠ æ®µè½
                const lines = statement.split('\n');
                lines.forEach(line => {
                    if (line.trim()) {
                        const p = document.createElement('p');
                        p.textContent = line;
                        p.style.marginBottom = '20px';
                        statementContent.appendChild(p);
                    } else {
                        statementContent.appendChild(document.createElement('br'));
                    }
                });
                
                // éšè—é—®å€™åŒºåŸŸï¼Œæ˜¾ç¤ºè¯­å¥åŒºåŸŸ
                greetingContainer.style.display = 'none';
                statementDisplay.classList.add('active');
                
                // ä¸å†è®¾ç½®è¿”å›ç¬¬ä¸€é¡µçš„å®šæ—¶å™¨ï¼Œä¼šä¸€ç›´åœç•™åœ¨å½“å‰é¡µé¢
            }
            
            // çƒŸèŠ±ç³»ç»Ÿå‡½æ•°
            function initFireworksSystem() {
                const canvas = document.getElementById('fireworksCanvas');
                const ctx = canvas.getContext('2d', { alpha: true });
                
                function resizeCanvas() {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                }
                
                resizeCanvas();
                
                // æ€§èƒ½ä¼˜åŒ–ï¼šé˜²æŠ–å¤„ç†resizeäº‹ä»¶
                let resizeTimeout;
                window.addEventListener('resize', function() {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(resizeCanvas, 100);
                });
                
                let fireworks = [];
                let particles = [];
                let heartExplosions = [];
                let lastFireworkTime = 0;
                
                // æ£€æµ‹æ˜¯å¦ä¸ºç§»åŠ¨ç«¯
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 768;
                const particleMultiplier = isMobile ? 0.6 : 1;
                
                // ä½¿ç”¨requestAnimationFrameè‡ªåŠ¨é€‚é…å¸§ç‡
                let lastTime = 0;
                
                // ç‰©ç†å‚æ•° - é«˜åº¦çœŸå®æ„Ÿè°ƒä¼˜
                const GRAVITY = 0.15;
                const EXPLOSION_HEIGHT_RATIO = 0.55;
                const WIND = 0.018;
                const AIR_RESISTANCE = 0.97;
                
                // é¢œè‰²é¢„è®¾
                const COLOR_PRESETS = [
                    // ä¸»è‰²è°ƒ
                    {hue: 0, saturation: 100, lightness: 75, type: 'single'},
                    {hue: 30, saturation: 100, lightness: 75, type: 'single'},
                    {hue: 60, saturation: 100, lightness: 75, type: 'single'},
                    {hue: 120, saturation: 100, lightness: 75, type: 'single'},
                    {hue: 180, saturation: 100, lightness: 75, type: 'single'},
                    {hue: 240, saturation: 100, lightness: 75, type: 'single'},
                    {hue: 270, saturation: 100, lightness: 75, type: 'single'},
                    {hue: 300, saturation: 100, lightness: 75, type: 'single'},
                    {hue: 330, saturation: 100, lightness: 75, type: 'single'},
                    
                    // æ¸å˜è‰²è°ƒ
                    {hue: 15, saturation: 100, lightness: 70, type: 'gradient'},
                    {hue: 180, saturation: 100, lightness: 65, type: 'gradient'},
                    {hue: 280, saturation: 100, lightness: 70, type: 'gradient'},
                    {hue: 90, saturation: 100, lightness: 65, type: 'gradient'},
                    
                    // å½©èŠå‹ä¸“ç”¨é¢œè‰²
                    {hue: 0, saturation: 100, lightness: 70, type: 'chrysanthemum'},
                    {hue: 30, saturation: 100, lightness: 70, type: 'chrysanthemum'},
                    {hue: 60, saturation: 100, lightness: 70, type: 'chrysanthemum'},
                    {hue: 90, saturation: 100, lightness: 70, type: 'chrysanthemum'},
                    {hue: 120, saturation: 100, lightness: 70, type: 'chrysanthemum'},
                    {hue: 150, saturation: 100, lightness: 70, type: 'chrysanthemum'},
                    {hue: 180, saturation: 100, lightness: 70, type: 'chrysanthemum'},
                    {hue: 210, saturation: 100, lightness: 70, type: 'chrysanthemum'},
                    {hue: 240, saturation: 100, lightness: 70, type: 'chrysanthemum'},
                    {hue: 270, saturation: 100, lightness: 70, type: 'chrysanthemum'},
                    {hue: 300, saturation: 100, lightness: 70, type: 'chrysanthemum'},
                    {hue: 330, saturation: 100, lightness: 70, type: 'chrysanthemum'},
                ];
                
                // çˆ†ç‚¸æ¨¡å¼åˆ†ç±»
                const EXPLOSION_PATTERNS = {
                    CIRCLE: 'circle',
                    SPARKLE: 'sparkle',
                    VORTEX: 'vortex',
                    RAINBOW: 'rainbow',
                    RING: 'ring',
                    SUN: 'sun',
                    BURST: 'burst',
                    CASCADE: 'cascade',
                    HEART: 'heart',
                    METEOR_SHOWER: 'meteor_shower',
                    FIRE_TREE: 'fire_tree',
                    ELLIPSE: 'ellipse',
                    CHRYSANTHEMUM: 'chrysanthemum',
                    PARAMETRIC_CIRCLE: 'parametric_circle',
                    PARAMETRIC_ELLIPSE: 'parametric_ellipse',
                    PARAMETRIC_STAR: 'parametric_star',
                    SPIRAL_PARAMETRIC: 'spiral_parametric'
                };
                
                // ç®€åŒ–éšæœºå‡½æ•°
                const random = (min, max) => Math.random() * (max - min) + min;
                const randomInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
                
                // éšæœºçˆ†ç‚¸æ¨¡å¼é€‰æ‹©
                function getRandomExplosionPattern() {
                    const weightedPatterns = [];
                    
                    // æ™®é€šçƒŸèŠ±æ¨¡å¼ï¼š20%
                    const normalPatterns = [
                        EXPLOSION_PATTERNS.CIRCLE,
                        EXPLOSION_PATTERNS.SPARKLE,
                        EXPLOSION_PATTERNS.VORTEX,
                        EXPLOSION_PATTERNS.RAINBOW,
                        EXPLOSION_PATTERNS.RING,
                        EXPLOSION_PATTERNS.SUN,
                        EXPLOSION_PATTERNS.BURST,
                        EXPLOSION_PATTERNS.CASCADE
                    ];
                    
                    const counts = [6, 6, 6, 6, 6, 5, 5, 5];
                    
                    for (let i = 0; i < normalPatterns.length; i++) {
                        for (let j = 0; j < counts[i]; j++) {
                            weightedPatterns.push(normalPatterns[i]);
                        }
                    }
                    
                    // å‚æ•°æ–¹ç¨‹æ¨¡å¼ï¼š40%
                    for (let i = 0; i < 54; i++) weightedPatterns.push(EXPLOSION_PATTERNS.PARAMETRIC_CIRCLE);
                    for (let i = 0; i < 18; i++) weightedPatterns.push(EXPLOSION_PATTERNS.PARAMETRIC_ELLIPSE);
                    for (let i = 0; i < 14; i++) weightedPatterns.push(EXPLOSION_PATTERNS.PARAMETRIC_STAR);
                    for (let i = 0; i < 4; i++) weightedPatterns.push(EXPLOSION_PATTERNS.SPIRAL_PARAMETRIC);
                    
                    // ç‰¹æ®ŠçƒŸèŠ±æ¨¡å¼ï¼š40%
                    for (let i = 0; i < 27; i++) weightedPatterns.push(EXPLOSION_PATTERNS.HEART);
                    for (let i = 0; i < 18; i++) weightedPatterns.push(EXPLOSION_PATTERNS.METEOR_SHOWER);
                    for (let i = 0; i < 11; i++) weightedPatterns.push(EXPLOSION_PATTERNS.FIRE_TREE);
                    for (let i = 0; i < 7; i++) weightedPatterns.push(EXPLOSION_PATTERNS.ELLIPSE);
                    for (let i = 0; i < 27; i++) weightedPatterns.push(EXPLOSION_PATTERNS.CHRYSANTHEMUM);
                    
                    return weightedPatterns[randomInt(0, weightedPatterns.length - 1)];
                }
                
                // è·å–éšæœºé¢œè‰²é…ç½®
                function getRandomColorConfig(pattern) {
                    if (pattern === EXPLOSION_PATTERNS.CHRYSANTHEMUM) {
                        const chrysanthemumColors = COLOR_PRESETS.filter(c => c.type === 'chrysanthemum');
                        return chrysanthemumColors[randomInt(0, chrysanthemumColors.length - 1)];
                    }
                    
                    const color1 = COLOR_PRESETS[randomInt(0, COLOR_PRESETS.length - 1)];
                    
                    if (Math.random() < 0.3) {
                        const color2 = COLOR_PRESETS[randomInt(0, COLOR_PRESETS.length - 1)];
                        return {
                            hue: color1.hue,
                            saturation: color1.saturation,
                            lightness: color1.lightness,
                            type: 'dual',
                            secondHue: color2.hue,
                            secondSaturation: color2.saturation,
                            secondLightness: color2.lightness
                        };
                    }
                    
                    return color1;
                }
                
                // ç®€åŒ–çˆ±å¿ƒçˆ†ç‚¸ç®¡ç†å™¨
                class HeartExplosionManager {
                    constructor(x, y, colorConfig, explosionPower) {
                        this.x = x;
                        this.y = y;
                        this.colorConfig = colorConfig;
                        this.explosionPower = explosionPower;
                        
                        this.createdAt = Date.now();
                        this.lifetime = 1500;
                        this.heartParticles = [];
                        
                        this.createHeartParticles();
                    }
                    
                    createHeartParticles() {
                        const baseCount = isMobile ? randomInt(70, 110) : randomInt(120, 180);
                        const particleCount = Math.floor(baseCount * particleMultiplier);
                        
                        for (let i = 0; i < particleCount; i++) {
                            const t = (i / particleCount) * Math.PI * 2;
                            
                            const sinT = Math.sin(t);
                            const cosT = Math.cos(t);
                            const cos2T = Math.cos(2 * t);
                            const cos3T = Math.cos(3 * t);
                            const cos4T = Math.cos(4 * t);
                            
                            const heartX = 16 * Math.pow(sinT, 3);
                            const heartY = 13 * cosT - 5 * cos2T - 2 * cos3T - cos4T;
                            
                            const scale = 5.5 * this.explosionPower;
                            const x = this.x + heartX * scale;
                            const y = this.y - heartY * scale;
                            
                            const heartParticle = new SimplifiedHeartParticle(
                                x, y, 
                                this.colorConfig,
                                this.explosionPower,
                                t
                            );
                            
                            this.heartParticles.push(heartParticle);
                        }
                    }
                    
                    update(deltaTime) {
                        const deltaSeconds = deltaTime / 1000;
                        const currentTime = Date.now();
                        const elapsed = currentTime - this.createdAt;
                        
                        for (let i = this.heartParticles.length - 1; i >= 0; i--) {
                            this.heartParticles[i].update(deltaTime, elapsed);
                        }
                        
                        return elapsed < this.lifetime;
                    }
                    
                    draw(ctx) {
                        for (const heartParticle of this.heartParticles) {
                            heartParticle.draw(ctx);
                        }
                    }
                }
                
                // ç®€åŒ–çˆ±å¿ƒç²’å­ç±»
                class SimplifiedHeartParticle {
                    constructor(x, y, colorConfig, explosionPower, phase) {
                        this.x = x;
                        this.y = y;
                        this.originalX = x;
                        this.originalY = y;
                        this.colorConfig = colorConfig;
                        this.explosionPower = explosionPower;
                        this.phase = phase;
                        
                        this.baseSize = random(1.5, 2.5);
                        this.currentSize = this.baseSize;
                        this.life = 1.0;
                        
                        this.t = phase;
                        this.scale = 5.5 * this.explosionPower;
                        
                        this.updatePositionFromParametric();
                        
                        this.hue = colorConfig.hue;
                        this.saturation = colorConfig.saturation;
                        this.lightness = colorConfig.lightness;
                        
                        this.twinkleSpeed = random(0.8, 1.5);
                        this.twinklePhase = random(0, Math.PI * 2);
                        this.twinkleAmount = random(0.1, 0.2);
                    }
                    
                    updatePositionFromParametric() {
                        const sinT = Math.sin(this.t);
                        const cosT = Math.cos(this.t);
                        const cos2T = Math.cos(2 * this.t);
                        const cos3T = Math.cos(3 * this.t);
                        const cos4T = Math.cos(4 * this.t);
                        
                        const heartX = 16 * Math.pow(sinT, 3);
                        const heartY = 13 * cosT - 5 * cos2T - 2 * cos3T - cos4T;
                        
                        this.x = this.originalX + heartX * this.scale;
                        this.y = this.originalY - heartY * this.scale;
                    }
                    
                    update(deltaTime, elapsed) {
                        const deltaSeconds = deltaTime / 1000;
                        
                        this.life = Math.max(0, 1 - elapsed / 1500);
                        
                        if (Math.random() < 0.3) {
                            this.x += random(-0.8, 0.8);
                            this.y += random(-0.8, 0.8);
                        }
                        
                        const twinkle = Math.sin(Date.now() * 0.001 * this.twinkleSpeed + this.twinklePhase) * this.twinkleAmount;
                        this.currentSize = this.baseSize * (1 + twinkle) * this.life;
                        
                        return this.life > 0;
                    }
                    
                    draw(ctx) {
                        const alpha = this.life * 0.9;
                        
                        let hue, saturation, lightness;
                        
                        if (this.colorConfig.type === 'dual' && Math.random() > 0.5) {
                            hue = this.colorConfig.secondHue || this.colorConfig.hue;
                            saturation = this.colorConfig.secondSaturation || this.colorConfig.saturation;
                            lightness = this.colorConfig.secondLightness || this.colorConfig.lightness;
                        } else {
                            hue = this.hue;
                            saturation = this.saturation;
                            lightness = this.lightness;
                        }
                        
                        const color = `hsla(${hue}, ${saturation}%, ${lightness}%, ${alpha})`;
                        
                        ctx.fillStyle = color;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.currentSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                // æµæ˜Ÿç±»
                class Meteor {
                    constructor(x, y, colorConfig) {
                        this.x = x;
                        this.y = y;
                        this.colorConfig = colorConfig;
                        
                        this.size = random(1.8, 3.7);
                        this.length = random(18, 36);
                        this.speed = random(280, 550);
                        this.angle = random(-Math.PI/8, Math.PI/8);
                        this.life = 1.0;
                        this.decayRate = random(0.085, 0.22);
                        
                        this.vx = Math.sin(this.angle) * this.speed;
                        this.vy = Math.cos(this.angle) * this.speed;
                        
                        this.createdAt = Date.now();
                        
                        this.trailParticles = [];
                        this.lastTrailTime = 0;
                        this.fadeFactor = 1.5;
                    }
                    
                    update(deltaTime) {
                        const deltaSeconds = deltaTime / 1000;
                        const currentTime = Date.now();
                        
                        this.x += this.vx * deltaSeconds;
                        this.y += this.vy * deltaSeconds;
                        
                        this.vy += GRAVITY * 0.75 * deltaSeconds;
                        this.vx += WIND * random(-0.04, 0.04) * deltaSeconds;
                        
                        this.vx *= Math.pow(AIR_RESISTANCE, deltaSeconds * 60);
                        this.vy *= Math.pow(AIR_RESISTANCE, deltaSeconds * 60);
                        
                        this.life -= this.decayRate * deltaSeconds;
                        
                        if (currentTime - this.lastTrailTime > 22) {
                            this.trailParticles.push(new MeteorTrailParticle(
                                this.x,
                                this.y,
                                this.colorConfig
                            ));
                            this.lastTrailTime = currentTime;
                        }
                        
                        for (let i = this.trailParticles.length - 1; i >= 0; i--) {
                            if (!this.trailParticles[i].update(deltaTime)) {
                                this.trailParticles.splice(i, 1);
                            }
                        }
                        
                        if (this.trailParticles.length > (isMobile ? 15 : 25)) {
                            this.trailParticles.splice(0, this.trailParticles.length - (isMobile ? 12 : 20));
                        }
                        
                        return this.life > 0 && this.y < canvas.height + 45;
                    }
                    
                    draw(ctx) {
                        const alpha = Math.max(0, 1 - (1 - this.life) * this.fadeFactor) * 0.85;
                        const color = `hsla(${this.colorConfig.hue}, ${this.colorConfig.saturation}%, ${this.colorConfig.lightness}%, ${alpha})`;
                        
                        ctx.fillStyle = color;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                        ctx.fill();
                        
                        const gradient = ctx.createLinearGradient(
                            this.x, this.y,
                            this.x - Math.sin(this.angle) * this.length,
                            this.y - Math.cos(this.angle) * this.length
                        );
                        
                        gradient.addColorStop(0, `hsla(${this.colorConfig.hue}, ${this.colorConfig.saturation}%, ${this.colorConfig.lightness}%, ${alpha})`);
                        gradient.addColorStop(0.5, `hsla(${this.colorConfig.hue}, ${this.colorConfig.saturation}%, ${this.colorConfig.lightness}%, ${alpha * 0.45})`);
                        gradient.addColorStop(1, `hsla(${this.colorConfig.hue}, ${this.colorConfig.saturation}%, ${this.colorConfig.lightness}%, 0)`);
                        
                        ctx.strokeStyle = gradient;
                        ctx.lineWidth = this.size * 0.75;
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y);
                        ctx.lineTo(
                            this.x - Math.sin(this.angle) * this.length,
                            this.y - Math.cos(this.angle) * this.length
                        );
                        ctx.stroke();
                        
                        for (const trailParticle of this.trailParticles) {
                            trailParticle.draw(ctx);
                        }
                    }
                }
                
                // æµæ˜Ÿè½¨è¿¹ç²’å­ç±»
                class MeteorTrailParticle {
                    constructor(x, y, colorConfig) {
                        this.x = x;
                        this.y = y;
                        this.colorConfig = colorConfig;
                        
                        this.size = random(0.9, 2.3);
                        this.life = 1.0;
                        this.decayRate = random(0.055, 0.18);
                        
                        this.vx = random(-8, 8);
                        this.vy = random(-8, 8);
                        
                        this.fadeFactor = 1.5;
                    }
                    
                    update(deltaTime) {
                        const deltaSeconds = deltaTime / 1000;
                        
                        this.x += this.vx * deltaSeconds;
                        this.y += this.vy * deltaSeconds;
                        
                        this.vy += GRAVITY * 0.25 * deltaSeconds;
                        
                        this.vx *= Math.pow(AIR_RESISTANCE, deltaSeconds * 60);
                        this.vy *= Math.pow(AIR_RESISTANCE, deltaSeconds * 60);
                        
                        this.life -= this.decayRate * deltaSeconds;
                        
                        return this.life > 0;
                    }
                    
                    draw(ctx) {
                        const alpha = Math.max(0, 1 - (1 - this.life) * this.fadeFactor) * 0.55;
                        const color = `hsla(${this.colorConfig.hue}, ${this.colorConfig.saturation}%, ${this.colorConfig.lightness}%, ${alpha})`;
                        
                        ctx.fillStyle = color;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                // ç«æ ‘é“¶èŠ±ç²’å­ç±»
                class FireTreeParticle {
                    constructor(x, y, colorConfig) {
                        this.x = x;
                        this.y = y;
                        this.colorConfig = colorConfig;
                        
                        this.baseSize = random(1.6, 3.2);
                        this.currentSize = this.baseSize;
                        this.life = 1.0;
                        this.decayRate = random(0.01, 0.03);
                        
                        this.twinkleSpeed = random(1.1, 2.8);
                        this.twinklePhase = random(0, Math.PI * 2);
                        this.twinkleAmount = random(0.25, 0.55);
                        
                        this.phase = 1;
                        this.phaseDuration = random(0.9, 2.0);
                        this.phaseTime = 0;
                        
                        const angle = random(-Math.PI, Math.PI);
                        const speed = random(110, 330);
                        this.vx = Math.cos(angle) * speed * 0.65;
                        this.vy = Math.sin(angle) * speed - 140;
                        
                        this.fallSpeed = random(25, 90);
                        this.swingAmount = random(18, 55);
                        this.swingSpeed = random(1.1, 3.2);
                        this.swingPhase = random(0, Math.PI * 2);
                        
                        this.sparkParticles = [];
                        this.lastSparkTime = 0;
                        
                        this.createdAt = Date.now();
                        this.fadeFactor = 1.5;
                    }
                    
                    update(deltaTime) {
                        const deltaSeconds = deltaTime / 1000;
                        const currentTime = Date.now();
                        this.phaseTime += deltaSeconds;
                        
                        if (this.phase === 1) {
                            this.x += this.vx * deltaSeconds;
                            this.y += this.vy * deltaSeconds;
                            
                            this.vy += GRAVITY * 0.18 * deltaSeconds;
                            this.vx += WIND * random(-0.018, 0.018) * deltaSeconds;
                            
                            this.vx *= Math.pow(AIR_RESISTANCE, deltaSeconds * 60);
                            this.vy *= Math.pow(AIR_RESISTANCE, deltaSeconds * 60);
                            
                            if (currentTime - this.lastSparkTime > 45) {
                                this.sparkParticles.push(new FireTreeSpark(
                                    this.x + random(-2.5, 2.5),
                                    this.y + random(-2.5, 2.5),
                                    this.colorConfig
                                ));
                                this.lastSparkTime = currentTime;
                            }
                            
                            if (this.phaseTime > this.phaseDuration) {
                                this.phase = 2;
                                this.vx = random(-18, 18);
                                this.vy = this.fallSpeed;
                            }
                        } else {
                            this.x += this.vx * deltaSeconds;
                            this.y += this.vy * deltaSeconds;
                            
                            const swing = Math.sin(currentTime * 0.001 * this.swingSpeed + this.swingPhase) * this.swingAmount * deltaSeconds;
                            this.x += swing;
                            
                            this.vy += GRAVITY * 0.65 * deltaSeconds;
                            this.vx += WIND * random(-0.009, 0.009) * deltaSeconds;
                            
                            this.vx *= Math.pow(AIR_RESISTANCE, deltaSeconds * 60);
                            
                            if (currentTime - this.lastSparkTime > 110) {
                                this.sparkParticles.push(new FireTreeSpark(
                                    this.x + random(-1.8, 1.8),
                                    this.y + random(-1.8, 1.8),
                                    this.colorConfig
                                ));
                                this.lastSparkTime = currentTime;
                            }
                        }
                        
                        this.life -= this.decayRate * deltaSeconds;
                        
                        const twinkle = Math.sin(currentTime * 0.001 * this.twinkleSpeed + this.twinklePhase) * this.twinkleAmount;
                        this.currentSize = this.baseSize * (1 + twinkle) * this.life;
                        
                        for (let i = this.sparkParticles.length - 1; i >= 0; i--) {
                            if (!this.sparkParticles[i].update(deltaTime)) {
                                this.sparkParticles.splice(i, 1);
                            }
                        }
                        
                        if (this.sparkParticles.length > (isMobile ? 8 : 12)) {
                            this.sparkParticles.splice(0, this.sparkParticles.length - (isMobile ? 6 : 10));
                        }
                        
                        return this.life > 0 && this.y < canvas.height + 70;
                    }
                    
                    draw(ctx) {
                        for (const spark of this.sparkParticles) {
                            spark.draw(ctx);
                        }
                        
                        const alpha = Math.max(0, 1 - (1 - this.life) * this.fadeFactor) * 0.85;
                        let color;
                        
                        if (this.colorConfig.type === 'silver' || this.colorConfig.type === 'light_silver') {
                            const brightness = 88 + Math.sin(Date.now() * 0.0018) * 8;
                            color = `hsla(${this.colorConfig.hue}, ${this.colorConfig.saturation}%, ${brightness}%, ${alpha})`;
                        } else if (this.colorConfig.type === 'gold' || this.colorConfig.type === 'light_gold') {
                            const brightness = 78 + Math.sin(Date.now() * 0.0025) * 12;
                            color = `hsla(${this.colorConfig.hue}, ${this.colorConfig.saturation}%, ${brightness}%, ${alpha})`;
                        } else {
                            const brightness = 93 + Math.sin(Date.now() * 0.0012) * 4;
                            color = `hsla(${this.colorConfig.hue}, ${this.colorConfig.saturation}%, ${brightness}%, ${alpha})`;
                        }
                        
                        ctx.fillStyle = color;
                        
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.currentSize, 0, Math.PI * 2);
                        ctx.fill();
                        
                        if (this.life > 0.6) {
                            ctx.globalAlpha = alpha * 0.35;
                            ctx.fillStyle = this.colorConfig.type.includes('silver') 
                                ? 'rgba(255, 255, 255, 0.25)'
                                : this.colorConfig.type.includes('gold')
                                    ? 'rgba(255, 215, 0, 0.25)'
                                    : 'rgba(255, 255, 255, 0.25)';
                            ctx.beginPath();
                            ctx.arc(this.x, this.y, this.currentSize * 1.4, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.globalAlpha = 1.0;
                        }
                    }
                }
                
                // ç«æ ‘é“¶èŠ±ç«èŠ±ç²’å­ç±»
                class FireTreeSpark {
                    constructor(x, y, colorConfig) {
                        this.x = x;
                        this.y = y;
                        this.colorConfig = colorConfig;
                        
                        this.size = random(0.7, 1.9);
                        this.life = 1.0;
                        this.decayRate = random(0.18, 0.38);
                        
                        this.vx = random(-18, 18);
                        this.vy = random(-18, 18);
                        
                        this.fadeFactor = 1.5;
                    }
                    
                    update(deltaTime) {
                        const deltaSeconds = deltaTime / 1000;
                        
                        this.x += this.vx * deltaSeconds;
                        this.y += this.vy * deltaSeconds;
                        
                        this.vy += GRAVITY * 0.4 * deltaSeconds;
                        
                        this.vx *= Math.pow(0.88, deltaSeconds * 60);
                        this.vy *= Math.pow(0.88, deltaSeconds * 60);
                        
                        this.life -= this.decayRate * deltaSeconds;
                        
                        return this.life > 0;
                    }
                    
                    draw(ctx) {
                        const alpha = Math.max(0, 1 - (1 - this.life) * this.fadeFactor) * 0.65;
                        let color;
                        
                        if (this.colorConfig.type === 'silver' || this.colorConfig.type === 'light_silver') {
                            color = `hsla(${this.colorConfig.hue}, ${this.colorConfig.saturation}%, 92%, ${alpha})`;
                        } else if (this.colorConfig.type === 'gold' || this.colorConfig.type === 'light_gold') {
                            color = `hsla(${this.colorConfig.hue}, ${this.colorConfig.saturation}%, 87%, ${alpha})`;
                        } else {
                            color = `hsla(${this.colorConfig.hue}, ${this.colorConfig.saturation}%, 92%, ${alpha})`;
                        }
                        
                        ctx.fillStyle = color;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                // å½©èŠå‹ç²’å­ç±»
                class ChrysanthemumParticle {
                    constructor(x, y, colorConfig, explosionPower = 1) {
                        this.x = x;
                        this.y = y;
                        this.colorConfig = colorConfig;
                        this.explosionPower = explosionPower;
                        
                        this.baseSize = random(1.1, 2.2);
                        this.currentSize = this.baseSize;
                        this.life = 1.0;
                        this.decayRate = random(0.085, 0.22);
                        
                        this.hueShift = random(-18, 18);
                        this.originalHue = colorConfig.hue;
                        
                        const angle = random(0, Math.PI * 2);
                        const speed = random(165, 320) * explosionPower;
                        this.vx = Math.cos(angle) * speed;
                        this.vy = Math.sin(angle) * speed;
                        
                        this.curveFactor = random(0.25, 0.85);
                        this.curveTime = 0;
                        
                        this.isFireSpark = true;
                        this.fireSparkDuration = random(0.12, 0.28);
                        this.colorMixRatio = 0;
                        this.colorMixSpeed = random(0.55, 1.1);
                        
                        this.sparkleFactor = random(0.22, 0.42);
                        this.sparklePhase = random(0, Math.PI * 2);
                        
                        this.createdAt = Date.now();
                        
                        this.tailParticles = [];
                        this.fadeFactor = 1.5;
                    }
                    
                    update(deltaTime) {
                        const deltaSeconds = deltaTime / 1000;
                        this.curveTime += deltaSeconds;
                        
                        this.x += this.vx * deltaSeconds;
                        this.y += this.vy * deltaSeconds;
                        
                        const curve = Math.sin(this.curveTime * 0.0025) * this.curveFactor;
                        this.vx += curve * deltaSeconds * 35;
                        this.vy += curve * deltaSeconds * 35;
                        
                        this.vy += GRAVITY * 0.55 * deltaSeconds;
                        this.vx += WIND * random(-0.025, 0.025) * deltaSeconds;
                        
                        this.vx *= Math.pow(AIR_RESISTANCE, deltaSeconds * 60);
                        this.vy *= Math.pow(AIR_RESISTANCE, deltaSeconds * 60);
                        
                        this.life -= this.decayRate * deltaSeconds;
                        
                        const aliveTime = (Date.now() - this.createdAt) / 1000;
                        if (this.isFireSpark && aliveTime > this.fireSparkDuration) {
                            this.isFireSpark = false;
                        }
                        
                        if (!this.isFireSpark && this.colorMixRatio < 1) {
                            this.colorMixRatio = Math.min(1, this.colorMixRatio + this.colorMixSpeed * deltaSeconds);
                        }
                        
                        this.currentSize = this.baseSize * this.life;
                        
                        if (this.sparkleFactor > 0) {
                            this.currentSize *= 1 + Math.sin(Date.now() * 0.007 + this.sparklePhase) * this.sparkleFactor;
                        }
                        
                        if (Math.random() < (isMobile ? 0.12 : 0.18)) {
                            this.tailParticles.push(new ChrysanthemumTailParticle(
                                this.x,
                                this.y,
                                this.colorConfig,
                                this.life
                            ));
                        }
                        
                        for (let i = this.tailParticles.length - 1; i >= 0; i--) {
                            if (!this.tailParticles[i].update(deltaTime)) {
                                this.tailParticles.splice(i, 1);
                            }
                        }
                        
                        if (this.tailParticles.length > (isMobile ? 6 : 8)) {
                            this.tailParticles.splice(0, this.tailParticles.length - (isMobile ? 5 : 7));
                        }
                        
                        return this.life > 0 && this.y < canvas.height + 75;
                    }
                    
                    draw(ctx) {
                        for (const tailParticle of this.tailParticles) {
                            tailParticle.draw(ctx);
                        }
                        
                        const alpha = Math.max(0, 1 - (1 - this.life) * this.fadeFactor);
                        
                        let color;
                        if (this.isFireSpark) {
                            const brightness = 88 + Math.sin(Date.now() * 0.004) * 7;
                            color = `hsla(60, 100%, ${brightness}%, ${alpha * 0.82})`;
                        } else {
                            const hue = (this.originalHue + this.hueShift * this.colorMixRatio) % 360;
                            const saturation = this.colorConfig.saturation;
                            const lightness = 68 + (this.colorConfig.lightness - 68) * this.colorMixRatio;
                            
                            color = `hsla(${hue}, ${saturation}%, ${lightness}%, ${alpha * 0.72})`;
                        }
                        
                        ctx.fillStyle = color;
                        
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.currentSize, 0, Math.PI * 2);
                        ctx.fill();
                        
                        if (this.life > 0.5) {
                            ctx.globalAlpha = this.life * 0.22;
                            ctx.fillStyle = this.isFireSpark ? 'rgba(255, 255, 235, 0.35)' : `hsla(${this.colorConfig.hue}, 62%, 78%, 0.22)`;
                            ctx.beginPath();
                            ctx.arc(this.x, this.y, this.currentSize * 1.12, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.globalAlpha = 1.0;
                        }
                    }
                }
                
                // å½©èŠå‹å°¾éƒ¨ç²’å­ç±»
                class ChrysanthemumTailParticle {
                    constructor(x, y, colorConfig, parentLife) {
                        this.x = x;
                        this.y = y;
                        this.colorConfig = colorConfig;
                        
                        this.size = random(0.6, 1.6);
                        this.life = parentLife * random(0.45, 0.75);
                        this.decayRate = random(0.12, 0.28);
                        
                        this.vx = random(-12, 12);
                        this.vy = random(-12, 12);
                        
                        this.fadeFactor = 1.5;
                    }
                    
                    update(deltaTime) {
                        const deltaSeconds = deltaTime / 1000;
                        
                        this.x += this.vx * deltaSeconds;
                        this.y += this.vy * deltaSeconds;
                        
                        this.vy += GRAVITY * 0.35 * deltaSeconds;
                        
                        this.vx *= Math.pow(AIR_RESISTANCE, deltaSeconds * 60);
                        this.vy *= Math.pow(AIR_RESISTANCE, deltaSeconds * 60);
                        
                        this.life -= this.decayRate * deltaSeconds;
                        
                        return this.life > 0;
                    }
                    
                    draw(ctx) {
                        const alpha = Math.max(0, 1 - (1 - this.life) * this.fadeFactor) * 0.48;
                        const hue = this.colorConfig.hue;
                        const saturation = this.colorConfig.saturation;
                        const lightness = this.colorConfig.lightness;
                        
                        const color = `hsla(${hue}, ${saturation}%, ${lightness}%, ${alpha})`;
                        
                        ctx.fillStyle = color;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                // å‚æ•°æ–¹ç¨‹èºæ—‹ç²’å­ç±»
                class ParametricSpiralParticle {
                    constructor(x, y, colorConfig, explosionPower) {
                        this.x = x;
                        this.y = y;
                        this.colorConfig = colorConfig;
                        this.explosionPower = explosionPower;
                        
                        this.theta = random(0, Math.PI * 12);
                        this.a = random(1.5, 3.0);
                        this.angularSpeed = random(2.0, 4.0);
                        this.radialSpeed = random(80, 150) * explosionPower;
                        
                        this.baseSize = random(1.0, 2.2);
                        this.currentSize = this.baseSize;
                        this.life = 1.0;
                        this.decayRate = random(0.12, 0.25);
                        
                        this.spiralType = randomInt(0, 2);
                        
                        this.hueShift = random(-20, 20);
                        this.originalHue = colorConfig.hue;
                        
                        this.twinkleSpeed = random(2.0, 3.5);
                        this.twinklePhase = random(0, Math.PI * 2);
                        this.twinkleAmount = random(0.15, 0.3);
                        
                        this.createdAt = Date.now();
                        this.fadeFactor = 1.5;
                    }
                    
                    update(deltaTime) {
                        const deltaSeconds = deltaTime / 1000;
                        const currentTime = Date.now();
                        
                        this.theta += this.angularSpeed * deltaSeconds;
                        
                        let r;
                        switch (this.spiralType) {
                            case 0:
                                r = this.a * this.theta;
                                break;
                            case 1:
                                r = this.a * Math.sqrt(Math.abs(this.theta));
                                break;
                            case 2:
                                r = this.a / (Math.max(0.1, Math.abs(this.theta)));
                                break;
                            default:
                                r = this.a * this.theta;
                        }
                        
                        const newX = this.x + Math.cos(this.theta) * r;
                        const newY = this.y + Math.sin(this.theta) * r;
                        
                        this.vx = (newX - this.x) / deltaSeconds;
                        this.vy = (newY - this.y) / deltaSeconds;
                        
                        this.x = newX;
                        this.y = newY;
                        
                        this.vy += GRAVITY * 0.3 * deltaSeconds;
                        
                        this.life -= this.decayRate * deltaSeconds;
                        
                        const twinkle = Math.sin(currentTime * 0.001 * this.twinkleSpeed + this.twinklePhase) * this.twinkleAmount;
                        this.currentSize = this.baseSize * (1 + twinkle) * this.life;
                        
                        const radiusFactor = Math.min(2.0, r / 100);
                        this.currentSize *= (1 + radiusFactor * 0.3);
                        
                        return this.life > 0 && this.y < canvas.height + 90;
                    }
                    
                    draw(ctx) {
                        const alpha = Math.max(0, 1 - (1 - this.life) * this.fadeFactor) * 0.85;
                        
                        const hue = (this.originalHue + this.hueShift + this.theta * 20) % 360;
                        const saturation = this.colorConfig.saturation;
                        const lightness = this.colorConfig.lightness + Math.sin(this.theta) * 5;
                        
                        const color = `hsla(${hue}, ${saturation}%, ${lightness}%, ${alpha})`;
                        
                        ctx.fillStyle = color;
                        
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.currentSize, 0, Math.PI * 2);
                        ctx.fill();
                        
                        if (this.life > 0.6) {
                            ctx.globalAlpha = alpha * 0.3;
                            ctx.fillStyle = `hsla(${hue}, ${saturation}%, ${lightness + 15}%, 0.3)`;
                            ctx.beginPath();
                            ctx.arc(this.x, this.y, this.currentSize * 1.5, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.globalAlpha = 1.0;
                        }
                        
                        if (this.life > 0.8 && Math.random() < 0.3) {
                            ctx.strokeStyle = `hsla(${hue}, ${saturation}%, ${lightness}%, ${alpha * 0.2})`;
                            ctx.lineWidth = this.currentSize * 0.5;
                            ctx.lineCap = 'round';
                            ctx.beginPath();
                            ctx.moveTo(this.x, this.y);
                            ctx.lineTo(
                                this.x - this.vx * 0.02,
                                this.y - this.vy * 0.02
                            );
                            ctx.stroke();
                        }
                    }
                }
                
                // æ™®é€šç²’å­ç±»
                class Particle {
                    constructor(x, y, colorConfig, explosionPower = 1, explosionPattern = 'circle') {
                        this.x = x;
                        this.y = y;
                        this.colorConfig = colorConfig;
                        this.explosionPower = explosionPower;
                        this.explosionPattern = explosionPattern;
                        
                        const sizeMultiplier = explosionPattern.includes('SPARKLE') ? 0.82 : 0.98;
                        this.baseSize = random(0.9, 2.3) * sizeMultiplier;
                        this.currentSize = this.baseSize;
                        
                        this.isFireSpark = true;
                        this.fireSparkDuration = random(0.12, 0.32);
                        this.life = 1.0;
                        this.decayRate = random(0.13, 0.36);
                        
                        this.verticalWeight = random(0.55, 1.1);
                        this.horizontalDrag = AIR_RESISTANCE;
                        this.verticalDrag = AIR_RESISTANCE;
                        
                        this.setupExplosionPattern(explosionPattern, explosionPower);
                        
                        this.colorMixRatio = 0;
                        this.colorMixSpeed = random(0.65, 1.2);
                        
                        this.hueShift = random(-14, 14);
                        this.originalHue = colorConfig.hue;
                        
                        this.sparkleFactor = explosionPattern.includes('SPARKLE') ? random(0.1, 0.26) : 0;
                        this.sparklePhase = random(0, Math.PI * 2);
                        
                        this.secondaryExplosionChance = isMobile ? 0.01 : 0.02;
                        
                        this.createdAt = Date.now();
                        
                        this.useSecondColor = colorConfig.type === 'dual' && Math.random() > 0.5;
                        this.fadeFactor = 1.5;
                    }
                    
                    setupExplosionPattern(pattern, power) {
                        const baseSpeed = random(185, 350) * power;
                        
                        switch(pattern) {
                            case EXPLOSION_PATTERNS.CIRCLE:
                                const angle = random(0, Math.PI * 2);
                                this.vx = Math.cos(angle) * baseSpeed;
                                this.vy = Math.sin(angle) * baseSpeed;
                                break;
                                
                            case EXPLOSION_PATTERNS.SPARKLE:
                                const sparkleAngle = random(0, Math.PI * 2);
                                this.vx = Math.cos(sparkleAngle) * baseSpeed * 0.65;
                                this.vy = Math.sin(sparkleAngle) * baseSpeed * 0.65;
                                break;
                                
                            case EXPLOSION_PATTERNS.VORTEX:
                                const vortexAngle = random(0, Math.PI * 2);
                                this.vx = Math.cos(vortexAngle) * baseSpeed * 0.55;
                                this.vy = Math.sin(vortexAngle) * baseSpeed * 0.55;
                                this.vortexFactor = random(2.5, 5.5);
                                break;
                                
                            case EXPLOSION_PATTERNS.RAINBOW:
                                const rainbowAngle = random(0, Math.PI * 2);
                                this.vx = Math.cos(rainbowAngle) * baseSpeed;
                                this.vy = Math.sin(rainbowAngle) * baseSpeed;
                                this.rainbowHue = (Date.now() * 0.007 + random(0, 360)) % 360;
                                break;
                                
                            case EXPLOSION_PATTERNS.ELLIPSE:
                                const ellipseAngle = random(0, Math.PI * 2);
                                const ellipseFactor = random(0.35, 0.65);
                                this.vx = Math.cos(ellipseAngle) * baseSpeed;
                                this.vy = Math.sin(ellipseAngle) * baseSpeed * ellipseFactor;
                                break;
                                
                            case EXPLOSION_PATTERNS.PARAMETRIC_CIRCLE:
                                const circleTheta = random(0, Math.PI * 2);
                                const circleRadius = baseSpeed * random(0.8, 1.2);
                                this.vx = Math.cos(circleTheta) * circleRadius;
                                this.vy = Math.sin(circleTheta) * circleRadius;
                                this.isParametricCircle = true;
                                this.parametricTheta = circleTheta;
                                break;
                                
                            case EXPLOSION_PATTERNS.PARAMETRIC_ELLIPSE:
                                const ellipseTheta = random(0, Math.PI * 2);
                                const a = baseSpeed * random(1.0, 1.5);
                                const b = baseSpeed * random(0.5, 1.0);
                                this.vx = Math.cos(ellipseTheta) * a;
                                this.vy = Math.sin(ellipseTheta) * b;
                                this.isParametricEllipse = true;
                                this.parametricTheta = ellipseTheta;
                                this.a = a;
                                this.b = b;
                                break;
                                
                            case EXPLOSION_PATTERNS.PARAMETRIC_STAR:
                                const starTheta = random(0, Math.PI * 2);
                                const starSize = baseSpeed * random(0.7, 1.3);
                                const cos3 = Math.pow(Math.cos(starTheta), 3);
                                const sin3 = Math.pow(Math.sin(starTheta), 3);
                                this.vx = cos3 * starSize;
                                this.vy = sin3 * starSize;
                                this.isParametricStar = true;
                                this.parametricTheta = starTheta;
                                this.starTwinkleSpeed = random(3.0, 5.0);
                                this.starTwinklePhase = random(0, Math.PI * 2);
                                break;
                                
                            default:
                                const normalAngle = random(0, Math.PI * 2);
                                this.vx = Math.cos(normalAngle) * baseSpeed;
                                this.vy = Math.sin(normalAngle) * baseSpeed;
                                break;
                        }
                        
                        if (!pattern.includes('PARAMETRIC')) {
                            this.vx += random(-35, 35);
                            this.vy += random(-35, 35);
                        }
                    }
                    
                    update(deltaTime) {
                        const deltaSeconds = deltaTime / 1000;
                        
                        if (this.isParametricCircle || this.isParametricEllipse || this.isParametricStar) {
                            this.parametricTheta += deltaSeconds * 1.5;
                            
                            if (this.isParametricCircle) {
                                const radius = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                                this.vx = Math.cos(this.parametricTheta) * radius;
                                this.vy = Math.sin(this.parametricTheta) * radius;
                            } else if (this.isParametricEllipse) {
                                this.vx = Math.cos(this.parametricTheta) * this.a;
                                this.vy = Math.sin(this.parametricTheta) * this.b;
                            } else if (this.isParametricStar) {
                                const cos3 = Math.pow(Math.cos(this.parametricTheta), 3);
                                const sin3 = Math.pow(Math.sin(this.parametricTheta), 3);
                                const starSize = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                                this.vx = cos3 * starSize;
                                this.vy = sin3 * starSize;
                                
                                this.currentSize = this.baseSize * (1 + Math.sin(Date.now() * 0.001 * this.starTwinkleSpeed + this.starTwinklePhase) * 0.3);
                            }
                        }
                        
                        this.x += this.vx * deltaSeconds;
                        this.y += this.vy * deltaSeconds;
                        
                        this.vy += GRAVITY * this.verticalWeight * deltaSeconds;
                        this.vx += WIND * random(-0.016, 0.016) * deltaSeconds;
                        
                        this.vx *= Math.pow(this.horizontalDrag, deltaSeconds * 60);
                        this.vy *= Math.pow(this.verticalDrag, deltaSeconds * 60);
                        
                        this.life -= this.decayRate * deltaSeconds;
                        
                        const aliveTime = (Date.now() - this.createdAt) / 1000;
                        if (this.isFireSpark && aliveTime > this.fireSparkDuration) {
                            this.isFireSpark = false;
                        }
                        
                        if (!this.isFireSpark && this.colorMixRatio < 1) {
                            this.colorMixRatio = Math.min(1, this.colorMixRatio + this.colorMixSpeed * deltaSeconds);
                        }
                        
                        this.currentSize = this.baseSize * this.life;
                        
                        if (this.explosionPattern === EXPLOSION_PATTERNS.VORTEX) {
                            const spiralTime = Date.now() * 0.001;
                            this.vx += Math.cos(spiralTime + this.x * 0.01) * this.vortexFactor;
                            this.vy += Math.sin(spiralTime + this.y * 0.01) * this.vortexFactor;
                        }
                        
                        if (this.sparkleFactor > 0) {
                            this.currentSize *= 1 + Math.sin(Date.now() * 0.006 + this.sparklePhase) * this.sparkleFactor;
                        }
                        
                        if (this.explosionPattern === EXPLOSION_PATTERNS.RAINBOW) {
                            this.rainbowHue = (this.rainbowHue + deltaSeconds * 110) % 360;
                        }
                        
                        if (this.currentSize > 4.5 && Math.random() < this.secondaryExplosionChance * deltaSeconds * 60) {
                            this.createSecondaryExplosion();
                        }
                        
                        return this.life > 0 && this.y < canvas.height + 90;
                    }
                    
                    createSecondaryExplosion() {
                        const secondaryCount = isMobile ? randomInt(2, 8) : randomInt(4, 12);
                        for (let i = 0; i < secondaryCount; i++) {
                            const secondaryParticle = new Particle(
                                this.x,
                                this.y,
                                this.colorConfig,
                                this.explosionPower * 0.25,
                                'sparkle'
                            );
                            secondaryParticle.baseSize = random(0.4, 1.3);
                            secondaryParticle.decayRate = random(0.25, 0.55);
                            particles.push(secondaryParticle);
                        }
                    }
                    
                    draw(ctx) {
                        const alpha = Math.max(0, 1 - (1 - this.life) * this.fadeFactor);
                        
                        let color;
                        if (this.isFireSpark) {
                            const brightness = 88 + Math.sin(Date.now() * 0.0035) * 7;
                            color = `hsla(60, 100%, ${brightness}%, ${alpha * 0.88})`;
                        } else {
                            let hue, saturation, lightness;
                            
                            if (this.explosionPattern === EXPLOSION_PATTERNS.RAINBOW) {
                                hue = this.rainbowHue;
                                saturation = 100;
                                lightness = 72;
                            } else if (this.colorConfig.type === 'dual' && this.useSecondColor) {
                                hue = this.colorConfig.secondHue;
                                saturation = this.colorConfig.secondSaturation;
                                lightness = this.colorConfig.secondLightness;
                            } else {
                                hue = (this.originalHue + this.hueShift * this.colorMixRatio) % 360;
                                saturation = this.colorConfig.saturation;
                                lightness = this.colorConfig.lightness;
                            }
                            
                            const mixedHue = hue;
                            const mixedSaturation = saturation * this.colorMixRatio;
                            const mixedLightness = 68 + (lightness - 68) * this.colorMixRatio;
                            
                            color = `hsla(${mixedHue}, ${mixedSaturation}%, ${mixedLightness}%, ${alpha * 0.82})`;
                        }
                        
                        ctx.fillStyle = color;
                        
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.currentSize, 0, Math.PI * 2);
                        ctx.fill();
                        
                        if (this.life > 0.5) {
                            ctx.globalAlpha = this.life * 0.28;
                            ctx.fillStyle = this.isFireSpark ? 'rgba(255, 255, 235, 0.45)' : `hsla(${this.colorConfig.hue}, 62%, 78%, 0.28)`;
                            ctx.beginPath();
                            ctx.arc(this.x, this.y, this.currentSize * 1.18, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.globalAlpha = 1.0;
                        }
                    }
                }
                
                // çƒŸèŠ±ç±»
                class Firework {
                    constructor(x, targetY, colorConfig) {
                        this.x = x;
                        this.y = canvas.height;
                        this.targetY = targetY;
                        this.colorConfig = colorConfig;
                        
                        this.speed = random(380, 620);
                        
                        this.exploded = false;
                        this.explosionPower = random(1.25, 2.1);
                        this.explosionPattern = getRandomExplosionPattern();
                        
                        this.lineLength = random(11, 28);
                        this.lineWidth = 1.1;
                        this.lineColor = `hsla(60, 100%, 82%, 0.55)`;
                        
                        this.createdAt = Date.now();
                        
                        this.explosionCount = 0;
                        this.maxExplosions = isMobile ? randomInt(2, 4) : randomInt(3, 6);
                        
                        this.playLaunchSound();
                    }
                    
                    playLaunchSound() {
                        try {
                            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                            const oscillator = audioContext.createOscillator();
                            const gainNode = audioContext.createGain();
                            
                            oscillator.connect(gainNode);
                            gainNode.connect(audioContext.destination);
                            
                            oscillator.type = 'sine';
                            oscillator.frequency.setValueAtTime(370, audioContext.currentTime);
                            oscillator.frequency.exponentialRampToValueAtTime(650, audioContext.currentTime + 0.26);
                            
                            gainNode.gain.setValueAtTime(0.09, audioContext.currentTime);
                            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.31);
                            
                            oscillator.start(audioContext.currentTime);
                            oscillator.stop(audioContext.currentTime + 0.31);
                        } catch (error) {}
                    }
                    
                    update(deltaTime) {
                        if (!this.exploded) {
                            const deltaSeconds = deltaTime / 1000;
                            
                            this.y -= this.speed * deltaSeconds;
                            
                            if (this.y <= this.targetY) {
                                this.explode();
                                return false;
                            }
                            
                            return true;
                        }
                        
                        return false;
                    }
                    
                    explode() {
                        this.exploded = true;
                        this.explosionCount++;
                        
                        const powerMultiplier = isMobile ? 1.0 : 1.2;
                        this.createExplosion(this.x, this.y, this.explosionPower * powerMultiplier, this.explosionPattern);
                        
                        if (this.explosionCount < this.maxExplosions) {
                            const nextExplosionDelay = isMobile ? random(150, 400) : random(120, 350);
                            setTimeout(() => {
                                this.createSubsequentExplosion();
                            }, nextExplosionDelay);
                        }
                    }
                    
                    createSubsequentExplosion() {
                        this.explosionCount++;
                        
                        const distance = random(70, 185);
                        const angle = random(0, Math.PI * 2);
                        
                        const newX = this.x + Math.cos(angle) * distance;
                        const newY = this.y + Math.sin(angle) * distance;
                        
                        const subExplosionPower = this.explosionPower * (isMobile ? random(0.5, 0.8) : random(0.6, 0.9));
                        
                        this.createExplosion(newX, newY, subExplosionPower, this.explosionPattern);
                        
                        if (this.explosionCount < this.maxExplosions) {
                            const nextExplosionDelay = isMobile ? random(150, 400) : random(120, 350);
                            setTimeout(() => {
                                this.createSubsequentExplosion();
                            }, nextExplosionDelay);
                        } else if (!isMobile && Math.random() < 0.3 && this.explosionCount < this.maxExplosions + 2) {
                            const extraDelay = random(150, 400);
                            setTimeout(() => {
                                this.createSubsequentExplosion();
                            }, extraDelay);
                            this.maxExplosions += randomInt(1, 2);
                        }
                    }
                    
                    createExplosion(x, y, power, pattern) {
                        if (pattern === EXPLOSION_PATTERNS.HEART) {
                            heartExplosions.push(new HeartExplosionManager(x, y, this.colorConfig, power));
                            return;
                        }
                        
                        if (pattern === EXPLOSION_PATTERNS.METEOR_SHOWER) {
                            this.createMeteorShower(x, y, power);
                            return;
                        }
                        
                        if (pattern === EXPLOSION_PATTERNS.FIRE_TREE) {
                            this.createFireTree(x, y, power);
                            return;
                        }
                        
                        if (pattern === EXPLOSION_PATTERNS.CHRYSANTHEMUM) {
                            this.createChrysanthemum(x, y, power);
                            return;
                        }
                        
                        if (pattern === EXPLOSION_PATTERNS.SPIRAL_PARAMETRIC) {
                            this.createParametricSpiral(x, y, power);
                            return;
                        }
                        
                        this.createNormalExplosion(x, y, power, pattern);
                    }
                    
                    createParametricSpiral(x, y, power) {
                        const baseParticleCount = isMobile ? randomInt(40, 70) : randomInt(60, 100);
                        const particleCount = Math.floor(baseParticleCount * particleMultiplier);
                        
                        for (let i = 0; i < particleCount; i++) {
                            particles.push(new ParametricSpiralParticle(
                                x,
                                y,
                                this.colorConfig,
                                power
                            ));
                        }
                        
                        const baseCenterCount = isMobile ? randomInt(12, 25) : randomInt(20, 40);
                        const centerCount = Math.floor(baseCenterCount * particleMultiplier);
                        for (let i = 0; i < centerCount; i++) {
                            const angle = random(0, Math.PI * 2);
                            const speed = random(80, 180) * power;
                            const spark = new Particle(
                                x,
                                y,
                                this.colorConfig,
                                power * 0.6,
                                'sparkle'
                            );
                            spark.vx = Math.cos(angle) * speed;
                            spark.vy = Math.sin(angle) * speed;
                            spark.baseSize = random(0.8, 1.8);
                            spark.decayRate = random(0.25, 0.45);
                            particles.push(spark);
                        }
                    }
                    
                    createMeteorShower(x, y, power) {
                        const baseMeteorCount = isMobile ? randomInt(6, 12) : randomInt(9, 16);
                        const meteorCount = Math.floor(baseMeteorCount * particleMultiplier);
                        
                        for (let i = 0; i < meteorCount; i++) {
                            const meteor = new Meteor(
                                x + random(-32, 32),
                                y + random(-32, 32),
                                this.colorConfig
                            );
                            meteor.speed *= power;
                            particles.push(meteor);
                        }
                        
                        const baseSparkCount = isMobile ? randomInt(15, 30) : randomInt(22, 45);
                        const sparkCount = Math.floor(baseSparkCount * particleMultiplier);
                        for (let i = 0; i < sparkCount; i++) {
                            const spark = new Particle(
                                x + random(-45, 45),
                                y + random(-45, 45),
                                this.colorConfig,
                                power * 0.45,
                                'sparkle'
                            );
                            spark.baseSize = random(0.4, 1.4);
                            spark.decayRate = random(0.18, 0.38);
                            particles.push(spark);
                        }
                    }
                    
                    createFireTree(x, y, power) {
                        const baseTreeCount = isMobile ? randomInt(30, 50) : randomInt(45, 75);
                        const treeCount = Math.floor(baseTreeCount * particleMultiplier);
                        
                        for (let i = 0; i < treeCount; i++) {
                            const fireTreeParticle = new FireTreeParticle(
                                x + random(-22, 22),
                                y + random(-22, 22),
                                this.colorConfig
                            );
                            fireTreeParticle.baseSize *= power * 0.85;
                            fireTreeParticle.fallSpeed *= power;
                            particles.push(fireTreeParticle);
                        }
                        
                        const baseSparkCount = isMobile ? randomInt(15, 30) : randomInt(25, 45);
                        const sparkCount = Math.floor(baseSparkCount * particleMultiplier);
                        for (let i = 0; i < sparkCount; i++) {
                            const spark = new Particle(
                                x + random(-32, 32),
                                y + random(-32, 32),
                                this.colorConfig,
                                power * 0.55,
                                'sparkle'
                            );
                            spark.baseSize = random(0.9, 2.0);
                            spark.decayRate = random(0.28, 0.55);
                            spark.sparkleFactor = random(0.35, 0.65);
                            particles.push(spark);
                        }
                    }
                    
                    createChrysanthemum(x, y, power) {
                        const baseParticleCount = isMobile ? randomInt(70, 110) : randomInt(110, 170);
                        const particleCount = Math.floor(baseParticleCount * particleMultiplier);
                        
                        for (let i = 0; i < particleCount; i++) {
                            particles.push(new ChrysanthemumParticle(
                                x,
                                y,
                                this.colorConfig,
                                power
                            ));
                        }
                        
                        const sparkCount = Math.floor(particleCount * (isMobile ? 0.25 : 0.35));
                        for (let i = 0; i < sparkCount; i++) {
                            const spark = new ChrysanthemumParticle(
                                x + random(-13, 13),
                                y + random(-13, 13),
                                this.colorConfig,
                                power * 0.65
                            );
                            spark.baseSize = random(0.4, 1.6);
                            spark.decayRate = random(0.22, 0.45);
                            particles.push(spark);
                        }
                    }
                    
                    createNormalExplosion(x, y, power, pattern) {
                        const baseParticleCount = this.getParticleCountByPattern(pattern);
                        const particleCount = Math.floor(baseParticleCount * particleMultiplier);
                        
                        for (let i = 0; i < particleCount; i++) {
                            particles.push(new Particle(
                                x,
                                y,
                                this.colorConfig,
                                power,
                                pattern
                            ));
                        }
                        
                        const sparkCount = Math.floor(particleCount * (isMobile ? 0.25 : 0.35));
                        for (let i = 0; i < sparkCount; i++) {
                            const spark = new Particle(
                                x + random(-14, 14),
                                y + random(-14, 14),
                                this.colorConfig,
                                power * 0.65,
                                pattern === EXPLOSION_PATTERNS.SPARKLE ? pattern : 'sparkle'
                            );
                            spark.baseSize = random(0.4, 1.6);
                            spark.decayRate = random(0.22, 0.42);
                            particles.push(spark);
                        }
                    }
                    
                    getParticleCountByPattern(pattern) {
                        const mobileFactor = isMobile ? 0.7 : 1;
                        
                        switch(pattern) {
                            case EXPLOSION_PATTERNS.CIRCLE:
                                return Math.floor(randomInt(85, 130) * mobileFactor);
                            case EXPLOSION_PATTERNS.SPARKLE:
                                return Math.floor(randomInt(95, 150) * mobileFactor);
                            case EXPLOSION_PATTERNS.VORTEX:
                                return Math.floor(randomInt(90, 140) * mobileFactor);
                            case EXPLOSION_PATTERNS.RAINBOW:
                                return Math.floor(randomInt(115, 170) * mobileFactor);
                            case EXPLOSION_PATTERNS.ELLIPSE:
                                return Math.floor(randomInt(65, 115) * mobileFactor);
                            case EXPLOSION_PATTERNS.PARAMETRIC_CIRCLE:
                                return Math.floor(randomInt(100, 150) * mobileFactor);
                            case EXPLOSION_PATTERNS.PARAMETRIC_ELLIPSE:
                                return Math.floor(randomInt(80, 130) * mobileFactor);
                            case EXPLOSION_PATTERNS.PARAMETRIC_STAR:
                                return Math.floor(randomInt(120, 180) * mobileFactor);
                            case EXPLOSION_PATTERNS.SPIRAL_PARAMETRIC:
                                return Math.floor(randomInt(60, 100) * mobileFactor);
                            default:
                                return Math.floor(randomInt(65, 115) * mobileFactor);
                        }
                    }
                    
                    draw(ctx) {
                        if (!this.exploded) {
                            const lineEndY = this.y + this.lineLength;
                            if (lineEndY < canvas.height) {
                                ctx.strokeStyle = this.lineColor;
                                ctx.lineWidth = this.lineWidth;
                                ctx.beginPath();
                                ctx.moveTo(this.x, lineEndY);
                                ctx.lineTo(this.x, this.y);
                                ctx.stroke();
                            }
                            
                            ctx.fillStyle = 'hsla(60, 100%, 87%, 0.85)';
                            ctx.beginPath();
                            ctx.arc(this.x, this.y, 2.0, 0, Math.PI * 2);
                            ctx.fill();
                            
                            ctx.globalAlpha = 0.38;
                            ctx.fillStyle = 'hsla(60, 100%, 82%, 0.45)';
                            ctx.beginPath();
                            ctx.arc(this.x, this.y, 3.2, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.globalAlpha = 1.0;
                        }
                    }
                }
                
                // çƒŸèŠ±åˆ›å»ºå‡½æ•°
                function createRandomFirework() {
                    if (Math.random() < 0.22) return;
                    
                    const x = random(50, canvas.width - 50);
                    const targetY = random(canvas.height * 0.2, canvas.height * EXPLOSION_HEIGHT_RATIO);
                    const colorConfig = getRandomColorConfig();
                    
                    fireworks.push(new Firework(x, targetY, colorConfig));
                }
                
                // åˆ›å»ºç‰¹æ®ŠçƒŸèŠ±
                function createSpecialFirework() {
                    if (isMobile && Math.random() < 0.7) return;
                    if (!isMobile && Math.random() < 0.5) return;
                    
                    const x = random(100, canvas.width - 100);
                    const targetY = random(canvas.height * 0.15, canvas.height * 0.32);
                    const colorConfig = getRandomColorConfig();
                    
                    const specialFirework = new Firework(x, targetY, colorConfig);
                    specialFirework.explosionPower *= isMobile ? 1.2 : 1.45;
                    specialFirework.maxExplosions = isMobile ? randomInt(3, 5) : randomInt(4, 8);
                    fireworks.push(specialFirework);
                }
                
                // è‡ªåŠ¨å‘å°„ç³»ç»Ÿ
                function startAutoFire() {
                    if (isAutoFiring) return;
                    
                    isAutoFiring = true;
                    
                    // åˆå§‹å‘å°„çƒŸèŠ±æ•°é‡æ ¹æ®è®¾å¤‡è°ƒæ•´
                    setTimeout(() => createRandomFirework(), 300);
                    setTimeout(() => createRandomFirework(), 600);
                    if (!isMobile || Math.random() > 0.5) {
                        setTimeout(() => createSpecialFirework(), 900);
                    }
                    setTimeout(() => createRandomFirework(), 1200);
                    setTimeout(() => createRandomFirework(), 1500);
                    
                    autoFireInterval = setInterval(() => {
                        const now = Date.now();
                        const fireworkInterval = isMobile ? 1100 : 900;
                        if (now - lastFireworkTime > fireworkInterval) {
                            let count;
                            if (isMobile) {
                                count = Math.random() > 0.6 ? 2 : 1;
                            } else {
                                count = Math.random() > 0.3 ? 3 : (Math.random() > 0.5 ? 2 : 1);
                            }
                            
                            for (let i = 0; i < count; i++) {
                                setTimeout(() => {
                                    if (isMobile) {
                                        if (Math.random() > 0.8) {
                                            createSpecialFirework();
                                        } else {
                                            createRandomFirework();
                                        }
                                    } else {
                                        if (Math.random() > 0.6) {
                                            createSpecialFirework();
                                        } else {
                                            createRandomFirework();
                                        }
                                    }
                                }, i * (isMobile ? 150 : 120));
                            }
                            lastFireworkTime = now;
                        }
                    }, isMobile ? 1100 : 900);
                }
                
                // åŠ¨ç”»å¾ªç¯
                function animate(currentTime) {
                    const deltaTime = currentTime - lastTime || 0;
                    lastTime = currentTime;
                    
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.11)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    for (let i = fireworks.length - 1; i >= 0; i--) {
                        const firework = fireworks[i];
                        if (!firework.update(deltaTime)) {
                            fireworks.splice(i, 1);
                        } else {
                            firework.draw(ctx);
                        }
                    }
                    
                    for (let i = heartExplosions.length - 1; i >= 0; i--) {
                        if (!heartExplosions[i].update(deltaTime)) {
                            heartExplosions.splice(i, 1);
                        } else {
                            heartExplosions[i].draw(ctx);
                        }
                    }
                    
                    for (let i = particles.length - 1; i >= 0; i--) {
                        const particle = particles[i];
                        if (!particle.update(deltaTime)) {
                            particles.splice(i, 1);
                        } else {
                            particle.draw(ctx);
                        }
                    }
                    
                    const maxParticles = isMobile ? 1500 : 2200;
                    const keepParticles = isMobile ? 1300 : 1900;
                    if (particles.length > maxParticles) {
                        particles.splice(0, particles.length - keepParticles);
                    }
                    
                    if (fireworks.length > (isMobile ? 8 : 12)) {
                        fireworks.splice(0, fireworks.length - (isMobile ? 6 : 10));
                    }
                    
                    if (heartExplosions.length > (isMobile ? 3 : 4)) {
                        heartExplosions.splice(0, heartExplosions.length - (isMobile ? 2 : 3));
                    }
                    
                    fireworksAnimationId = requestAnimationFrame(animate);
                }
                
                // é¡µé¢å¯è§æ€§API
                let isPageVisible = true;
                
                document.addEventListener('visibilitychange', function() {
                    isPageVisible = !document.hidden;
                    
                    if (!isPageVisible) {
                        if (fireworksAnimationId) {
                            cancelAnimationFrame(fireworksAnimationId);
                            fireworksAnimationId = null;
                        }
                        if (bgMusic) {
                            bgMusic.pause();
                        }
                    } else {
                        if (!fireworksAnimationId) {
                            lastTime = performance.now();
                            animate(lastTime);
                        }
                        if (bgMusic.paused && musicPlayed) {
                            bgMusic.play().catch(() => {});
                        }
                    }
                });
                
                // åˆå§‹åŒ–çƒŸèŠ±ç³»ç»Ÿ
                function initFireworksSystem() {
                    lastTime = performance.now();
                    animate(lastTime);
                    
                    startAutoFire();
                }
                
                initFireworksSystem();
                
                // è¿”å›çƒŸèŠ±ç³»ç»Ÿæ§åˆ¶å‡½æ•°
                return {
                    stop: function() {
                        if (fireworksAnimationId) {
                            cancelAnimationFrame(fireworksAnimationId);
                            fireworksAnimationId = null;
                        }
                        if (autoFireInterval) {
                            clearInterval(autoFireInterval);
                            autoFireInterval = null;
                        }
                        if (bgMusic) {
                            bgMusic.pause();
                        }
                        isAutoFiring = false;
                        
                        // æ¸…ç©ºæ‰€æœ‰ç²’å­
                        fireworks = [];
                        particles = [];
                        heartExplosions = [];
                    }
                };
            }
            
            // è¿”å›ç¬¬ä¸€é¡µ
            function goBackToPage1() {
                // åœæ­¢çƒŸèŠ±ç³»ç»Ÿ
                if (fireworksSystem) {
                    fireworksSystem.stop();
                    fireworksSystem = null;
                }
                
                // æš‚åœéŸ³ä¹
                if (bgMusic) {
                    bgMusic.pause();
                    bgMusic.currentTime = 0;
                }
                
                // é‡ç½®éŸ³ä¹æ’­æ”¾çŠ¶æ€
                musicPlayed = false;
                
                // éšè—ç¬¬ä¸‰é¡µ
                page3.classList.remove('active');
                
                // éšè—ç¬¬äºŒé¡µ
                page2.classList.remove('active');
                
                // æ˜¾ç¤ºç¬¬ä¸€é¡µ
                setTimeout(() => {
                    page1.classList.remove('hidden');
                    
                    // æ¸…ç©ºè¾“å…¥æ¡†
                    nameInput.value = '';
                    
                    // æ¸…ç©ºåå­—æ˜¾ç¤ºåŒºåŸŸ
                    nameDisplay.innerHTML = '';
                    
                    // æ¸…ç©ºç¬¬ä¸‰é¡µæ˜¾ç¤ºåŒºåŸŸ
                    greetingContainer.style.display = 'flex';
                    greetingContainer.classList.remove('active');
                    greetingContainer.classList.remove('fade-out');
                    friendName.textContent = '';
                    statementDisplay.classList.remove('active');
                    statementContent.innerHTML = '';
                    
                    // é‡æ–°èšç„¦åˆ°è¾“å…¥æ¡†
                    nameInput.focus();
                }, 500);
            }
            
            // æäº¤æŒ‰é’®ç‚¹å‡»äº‹ä»¶
            submitBtn.addEventListener('click', submitName);
            
            // è¾“å…¥æ¡†å›è½¦äº‹ä»¶
            nameInput.addEventListener('keyup', function(event) {
                if (event.key === 'Enter') {
                    submitName();
                }
            });
            
            // å¯¹è¯æ°”æ³¡ç‚¹å‡»æ•ˆæœ
            const dialogueBoxes = document.querySelectorAll('.dialogue-box');
            dialogueBoxes.forEach(box => {
                box.addEventListener('click', function() {
                    this.classList.toggle('pulse');
                });
            });
            
            // æ·»åŠ é”®ç›˜å¿«æ·é”®æ”¯æŒ
            document.addEventListener('keydown', function(event) {
                // æŒ‰ç©ºæ ¼é”®åˆ‡æ¢èƒŒæ™¯
                if (event.key === ' ' && !page1.classList.contains('hidden')) {
                    document.body.style.background = document.body.style.background.includes('c3cfe2') 
                        ? "linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%)" 
                        : "linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%)";
                    event.preventDefault();
                }
                
                // æŒ‰ESCé”®è¿”å›ç¬¬ä¸€é¡µ
                if (event.key === 'Escape' && 
                    (page2.classList.contains('active') || page3.classList.contains('active'))) {
                    goBackToPage1();
                }
            });
            
            // åˆå§‹èšç„¦åˆ°è¾“å…¥æ¡†
            nameInput.focus();
            
            // æ·»åŠ é¡µé¢åŠ è½½åŠ¨ç”»
            document.body.style.opacity = 0;
            setTimeout(() => {
                document.body.style.transition = 'opacity 0.5s ease';
                document.body.style.opacity = 1;
            }, 100);
            
            // è§¦æ‘¸äº‹ä»¶å¤„ç†
            document.addEventListener('touchmove', function(e) {
                e.preventDefault();
            }, { passive: false });
            
            // é¡µé¢åŠ è½½æ—¶é¢„åŠ è½½éŸ³ä¹
            window.addEventListener('load', function() {
                // é¢„åŠ è½½éŸ³ä¹
                try {
                    bgMusic.load();
                    console.log("éŸ³ä¹é¢„åŠ è½½å®Œæˆ");
                } catch (error) {
                    console.log("éŸ³ä¹é¢„åŠ è½½å¤±è´¥:", error);
                }
            });
        });
    </script>
</body>
</html>
