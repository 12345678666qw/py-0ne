<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>我是云骨笛 你是谁？</title>
    <link href="https://fonts.googleapis.com/css2?family=Ma+Shan+Zheng&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Ma Shan Zheng', cursive, sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            color: #333;
            transition: background 0.5s ease;
            overflow: hidden;
        }
        
        /* 页面容器 */
        .page {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            transition: opacity 0.5s ease;
            overflow: hidden;
        }
        
        /* 第一页：对话页面 */
        #page1 {
            opacity: 1;
            z-index: 10;
        }
        
        #page1.hidden {
            opacity: 0;
            pointer-events: none;
            z-index: 0;
        }
        
        .container {
            width: 100%;
            max-width: 1200px;
            text-align: center;
        }
        
        .dialogue-container {
            display: flex;
            flex-direction: column;
            gap: 40px;
            margin-bottom: 60px;
        }
        
        .dialogue-box {
            position: relative;
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease;
        }
        
        .dialogue-box:hover {
            transform: translateY(-5px);
        }
        
        .yun-box {
            background: linear-gradient(to right, #a8edea 0%, #fed6e3 100%);
            align-self: flex-start;
            max-width: 60%;
            margin-left: 10%;
        }
        
        .ai-box {
            background: linear-gradient(to right, #d4fc79 0%, #96e6a1 100%);
            align-self: flex-end;
            max-width: 60%;
            margin-right: 10%;
        }
        
        .dialogue-text {
            font-size: 5rem;
            font-weight: bold;
            line-height: 1.2;
        }
        
        .yun-text {
            color: #2d3436;
        }
        
        .ai-text {
            color: #2d3436;
        }
        
        /* 输入区域样式 */
        .input-container {
            background: linear-gradient(to right, #fdfcfb 0%, #e2d1c3 100%);
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            max-width: 800px;
            margin: 0 auto;
        }
        
        .input-title {
            font-size: 2.5rem;
            margin-bottom: 30px;
            color: #2c3e50;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.1);
        }
        
        .input-group {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 30px;
        }
        
        .name-input {
            flex: 1;
            max-width: 400px;
            padding: 20px 25px;
            font-size: 2rem;
            font-family: 'Ma Shan Zheng', cursive;
            border: 3px solid #a8edea;
            border-radius: 15px;
            background: white;
            color: #2d3436;
            box-shadow: inset 0 5px 10px rgba(0, 0, 0, 0.05);
            transition: all 0.3s ease;
        }
        
        .name-input:focus {
            outline: none;
            border-color: #96e6a1;
            box-shadow: 0 0 0 4px rgba(150, 230, 161, 0.3), inset 0 5px 10px rgba(0, 0, 0, 0.05);
        }
        
        .submit-btn {
            padding: 20px 40px;
            font-size: 2rem;
            font-family: 'Ma Shan Zheng', cursive;
            background: linear-gradient(to right, #a8edea 0%, #fed6e3 100%);
            border: none;
            border-radius: 15px;
            color: #2d3436;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
        }
        
        .submit-btn:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.15);
        }
        
        .submit-btn:active {
            transform: translateY(0);
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
        }
        
        .error-message {
            color: #e74c3c;
            font-size: 1.8rem;
            margin-top: 15px;
            min-height: 30px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .error-message.show {
            opacity: 1;
        }
        
        /* 第二页：名字展示页面 */
        #page2 {
            opacity: 0;
            pointer-events: none;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
        }
        
        #page2.active {
            opacity: 1;
            pointer-events: all;
        }
        
        .name-display-container {
            text-align: center;
            max-width: 95%;
        }
        
        .name-display {
            font-size: 18rem;
            font-weight: bold;
            color: white;
            min-height: 250px;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            gap: 20px;
        }
        
        .name-char {
            display: inline-block;
        }
        
        /* 第三页：元旦快乐页面 */
        #page3 {
            opacity: 0;
            pointer-events: none;
            background: #000;
        }
        
        #page3.active {
            opacity: 1;
            pointer-events: all;
        }
        
        /* 烟花Canvas */
        #fireworksCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        
        /* 文字容器 */
        .text-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 2;
            pointer-events: none;
        }
        
        /* 修改后的元旦快乐文字区域 */
        .greeting-container {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 1200px;
            transition: opacity 1s ease;
            opacity: 0;
            white-space: nowrap; /* 添加这一行，确保不换行 */
        }
        
        .greeting-container.active {
            opacity: 1;
        }
        
        /* 朋友名字显示区域 */
        .friend-name {
            font-size: 10vw;
            font-weight: 900;
            color: #ffdd00;
            margin-bottom: 10px;
            line-height: 1.1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 100%;
        }
        
        /* 元旦快乐文字 - 确保在一行显示 */
        .new-year-text {
            font-size: 12vw;
            font-weight: 900;
            color: #ff3333;
            line-height: 1;
            white-space: nowrap; /* 确保不换行 */
            display: inline-block;
        }
        
        /* 新添加的：个性化语句显示区域 - 进一步扩大显示框 */
        .statement-display {
            width: 90%;
            max-width: 1200px;
            margin: 20px auto 0; /* 减少上边距，为更大的显示框留出空间 */
            padding: 40px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 20px;
            border: 2px solid rgba(255, 204, 0, 0.3);
            opacity: 0;
            transform: translateY(50px);
            transition: all 1s ease;
            /* 大幅增加最大高度，使文本框更长 */
            max-height: 700px; /* 从600px增加到700px */
            overflow-y: auto;
            display: none;
            position: relative;
            z-index: 20;
            /* 优化移动端滚动 */
            -webkit-overflow-scrolling: touch;
            /* 添加内部阴影，使滚动更明显 */
            box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.5);
        }
        
        .statement-display.active {
            opacity: 1;
            transform: translateY(0);
            display: block;
            animation: statementAppear 1.5s ease-out forwards;
        }
        
        .statement-content {
            font-size: 2.2rem;
            line-height: 1.8;
            color: #ffdd99;
            text-align: justify;
            text-shadow: 0 0 5px rgba(255, 221, 153, 0.5);
            padding: 20px;
            font-family: 'Ma Shan Zheng', cursive;
            word-wrap: break-word;
            overflow-wrap: break-word;
            white-space: pre-wrap; /* 保留换行符但允许自动换行 */
        }
        
        /* 响应式设计 - 进一步优化移动端 */
        @media (max-width: 1200px) {
            .dialogue-text {
                font-size: 3.5rem;
            }
            
            .name-display {
                font-size: 14rem;
            }
            
            .friend-name {
                font-size: 11vw;
            }
            
            .new-year-text {
                font-size: 13vw;
                white-space: nowrap; /* 确保不换行 */
            }
            
            .statement-content {
                font-size: 1.8rem;
            }
            
            .statement-display {
                max-height: 600px; /* 从500px增加到600px */
            }
        }
        
        @media (max-width: 992px) {
            .dialogue-text {
                font-size: 3rem;
            }
            
            .name-display {
                font-size: 12rem;
            }
            
            .friend-name {
                font-size: 12vw;
            }
            
            .new-year-text {
                font-size: 14vw;
                white-space: nowrap; /* 确保不换行 */
            }
            
            .statement-content {
                font-size: 1.6rem;
                padding: 15px;
            }
            
            .statement-display {
                max-height: 550px; /* 从450px增加到550px */
                padding: 30px;
            }
        }
        
        @media (max-width: 768px) {
            .dialogue-box {
                padding: 30px;
            }
            
            .yun-box, .ai-box {
                max-width: 85%;
                margin-left: 5%;
                margin-right: 5%;
            }
            
            .input-container {
                padding: 30px 20px;
            }
            
            .input-title {
                font-size: 2rem;
            }
            
            .input-group {
                flex-direction: column;
                align-items: center;
            }
            
            .name-input, .submit-btn {
                width: 100%;
                max-width: 100%;
                font-size: 1.8rem;
                padding: 18px;
            }
            
            .name-display {
                font-size: 9rem;
                gap: 15px;
            }
            
            /* 移动端优化：确保"元旦快乐！"在一行显示 */
            .greeting-container {
                white-space: nowrap;
                overflow: visible;
                padding: 0 10px;
            }
            
            .friend-name {
                font-size: 13vw;
                margin-bottom: 5px;
                white-space: nowrap;
                line-height: 1;
            }
            
            .new-year-text {
                font-size: 15vw;
                line-height: 0.9;
                white-space: nowrap; /* 强制不换行 */
                display: inline;
                word-break: keep-all; /* 防止断字 */
            }
            
            .statement-display {
                padding: 30px 20px;
                margin-top: 20px; /* 进一步减少上边距 */
                max-height: 500px; /* 从400px增加到500px，使文本框更长 */
                /* 在移动端增加更多内边距 */
                padding: 25px 20px;
            }
            
            .statement-content {
                font-size: 1.5rem;
                padding: 10px;
                line-height: 1.6;
            }
        }
        
        @media (max-width: 576px) {
            .dialogue-text {
                font-size: 2.5rem;
            }
            
            .dialogue-box {
                padding: 20px;
            }
            
            .input-title {
                font-size: 1.8rem;
            }
            
            .name-input, .submit-btn {
                font-size: 1.5rem;
            }
            
            .name-display {
                font-size: 7rem;
                gap: 10px;
                flex-direction: column;
            }
            
            /* 进一步优化小屏幕下的显示 */
            .greeting-container {
                transform: translate(-50%, -50%) scale(0.9);
                width: 95%;
            }
            
            .friend-name {
                font-size: 15vw;
                margin-bottom: 0;
            }
            
            .new-year-text {
                font-size: 17vw;
                white-space: nowrap;
                letter-spacing: -0.5px; /* 稍微收紧字母间距 */
            }
            
            .statement-display {
                padding: 20px 15px;
                margin-top: 15px;
                max-height: 450px; /* 从350px增加到450px，使文本框更长 */
                /* 调整边框和阴影 */
                border-width: 1.5px;
                box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.4);
            }
            
            .statement-content {
                font-size: 1.3rem;
                line-height: 1.6;
            }
        }
        
        @media (max-width: 480px) {
            .name-display {
                font-size: 5rem;
            }
            
            /* 优化超小屏幕显示 */
            .greeting-container {
                transform: translate(-50%, -50%) scale(0.85);
            }
            
            .friend-name {
                font-size: 16vw;
            }
            
            .new-year-text {
                font-size: 18vw;
                white-space: nowrap;
                letter-spacing: -1px;
            }
            
            .statement-display {
                padding: 15px 10px;
                max-height: 400px; /* 从300px增加到400px，使文本框更长 */
                margin-top: 10px;
                border-radius: 15px; /* 稍微减小圆角 */
            }
            
            .statement-content {
                font-size: 1.2rem;
                line-height: 1.5;
                padding: 8px;
            }
        }
        
        @media (max-width: 380px) {
            .friend-name {
                font-size: 17vw;
            }
            
            .new-year-text {
                font-size: 19vw;
                white-space: nowrap;
            }
            
            .greeting-container {
                padding: 0 5px;
                transform: translate(-50%, -50%) scale(0.8);
            }
            
            .statement-display {
                max-height: 380px; /* 从280px增加到380px，使文本框更长 */
                padding: 12px 8px;
                margin-top: 8px;
                border-radius: 12px;
            }
            
            .statement-content {
                font-size: 1.1rem;
                line-height: 1.4;
            }
        }
        
        @media (max-width: 320px) {
            /* 针对最小屏幕的优化 */
            .new-year-text {
                font-size: 20vw;
                white-space: nowrap;
            }
            
            .greeting-container {
                transform: translate(-50%, -50%) scale(0.75);
            }
            
            .statement-display {
                max-height: 350px; /* 从250px增加到350px，使文本框更长 */
                padding: 10px 6px;
                border-radius: 10px;
            }
            
            .statement-content {
                font-size: 1rem;
                line-height: 1.4;
                padding: 5px;
            }
        }
        
        @media (max-height: 600px) {
            /* 针对高度较小的屏幕进行特殊优化 */
            .statement-display {
                max-height: 300px; /* 在高度有限的屏幕上减少最大高度 */
                margin-top: 5px;
            }
            
            .greeting-container {
                transform: translate(-50%, -50%) scale(0.7);
            }
        }
        
        @media (max-height: 400px) {
            /* 针对高度非常小的屏幕进行特殊优化 */
            .statement-display {
                max-height: 200px;
                padding: 8px 5px;
            }
            
            .statement-content {
                font-size: 0.9rem;
                line-height: 1.3;
            }
            
            .greeting-container {
                transform: translate(-50%, -50%) scale(0.6);
            }
        }
        
        /* 动画效果 */
        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        @keyframes statementAppear {
            0% {
                opacity: 0;
                transform: translateY(50px) scale(0.9);
            }
            50% {
                opacity: 0.7;
                transform: translateY(-10px) scale(1.05);
            }
            100% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }
        
        .yun-box {
            animation: fadeInUp 1s ease-out 0.3s both;
        }
        
        .ai-box {
            animation: fadeInUp 1s ease-out 1s both;
        }
        
        .input-container {
            animation: fadeInUp 1s ease-out 1.5s both;
        }
        
        .pulse {
            display: inline-block;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        /* 第一阶段：名字字符放大显示动画 */
        .scale-up-char {
            opacity: 0;
            transform: scale(3);
            animation: scaleDownChar 1s ease-out forwards;
        }
        
        @keyframes scaleDownChar {
            to {
                opacity: 1;
                transform: scale(1);
            }
        }
        
        /* 第二阶段：名字三种特效的CSS定义 */
        .gradient-effect {
            background: linear-gradient(90deg, #ff9a9e, #fad0c4, #fad0c4, #a18cd1);
            background-size: 300% 100%;
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            animation: gradientMove 4s infinite alternate;
        }
        
        @keyframes gradientMove {
            0% { background-position: 0% 50%; }
            100% { background-position: 100% 50%; }
        }
        
        .bounce-effect {
            color: #ffdd59;
            animation: bounceChar 1.5s ease infinite;
        }
        
        @keyframes bounceChar {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-40px); }
        }
        
        .rainbow-effect {
            animation: rainbowColor 3s infinite;
        }
        
        @keyframes rainbowColor {
            0% { color: #ff3838; }
            20% { color: #ff9f1a; }
            40% { color: #fff200; }
            60% { color: #32ff7e; }
            80% { color: #18dcff; }
            100% { color: #7d5fff; }
        }
        
        /* 整体特效应用动画 */
        .whole-effect-apply {
            animation: wholeEffectApply 0.8s ease-out forwards;
        }
        
        @keyframes wholeEffectApply {
            0% { 
                opacity: 0;
                transform: scale(0.5);
            }
            50% { 
                opacity: 1;
                transform: scale(1.2);
            }
            100% { 
                opacity: 1;
                transform: scale(1);
            }
        }
        
        /* 元旦快乐文字消失动画 */
        .fade-out {
            animation: fadeOut 1s ease-out forwards;
        }
        
        @keyframes fadeOut {
            0% {
                opacity: 1;
                transform: scale(1);
            }
            100% {
                opacity: 0;
                transform: scale(0.5);
            }
        }
    </style>
</head>
<body>
    <!-- 第一页：对话页面 -->
    <div id="page1" class="page">
        <div class="container">
            <div class="dialogue-container">
                <div class="dialogue-box yun-box">
                    <div class="dialogue-text yun-text">我是云骨笛</div>
                </div>
                
                <div class="dialogue-box ai-box">
                    <div class="dialogue-text ai-text pulse">你是谁？</div>
                </div>
            </div>
            
            <div class="input-container">
                <h2 class="input-title">请输入你的名字：</h2>
                
                <div class="input-group">
                    <input type="text" class="name-input" id="nameInput" placeholder="请输入你的名字" maxlength="10">
                    <button class="submit-btn" id="submitBtn">
                        提交
                    </button>
                </div>
                
                <div class="error-message" id="errorMessage">
                    请输入有效的名字
                </div>
            </div>
        </div>
    </div>
    
    <!-- 第二页：名字展示页面 -->
    <div id="page2" class="page">
        <div class="name-display-container">
            <div class="name-display" id="nameDisplay">
                <!-- 名字将在这里显示 -->
            </div>
        </div>
    </div>
    
    <!-- 第三页：烟花和元旦快乐页面 -->
    <div id="page3" class="page">
        <canvas id="fireworksCanvas"></canvas>
        <div class="text-container">
            <!-- 修改后的元旦快乐问候区域 -->
            <div class="greeting-container" id="greetingContainer">
                <div class="friend-name" id="friendName"></div>
                <div class="new-year-text" id="newYearText">元旦快乐！</div>
            </div>
            
            <div class="statement-display" id="statementDisplay">
                <div class="statement-content" id="statementContent">
                    <!-- 个性化语句将在这里显示 -->
                </div>
            </div>
        </div>
        <!-- 背景音乐 -->
       <!-- 背景音乐 -->
        <audio id="bgMusic" loop preload="auto">
    您的浏览器不支持音频元素
        </audio>
        

        <script>
// 加载并应用音乐配置
        fetch('music-config.json')
           .then(res => res.json())
           .then(config => {
              const audio = document.getElementById('bgMusic');
    
        
        // 检查是否有正在播放的音乐状态
              const savedMusicUrl = sessionStorage.getItem('currentMusicUrl');
              const savedTime = sessionStorage.getItem('musicCurrentTime');
        
        // 如果音乐相同且有时间记录，恢复播放位置
              if (savedMusicUrl === config.musicUrl && savedTime) {
                 audio.currentTime = parseFloat(savedTime);
              }
        
        // 设置音乐
              audio.innerHTML = `<source src="${config.musicUrl}" type="audio/mpeg">`;
              audio.autoplay = config.autoplay;
              audio.loop = config.loop;
              audio.load();
        
        // 保存当前音乐信息到sessionStorage
              sessionStorage.setItem('currentMusicUrl', config.musicUrl);
        
        // 开始播放
              if (config.autoplay) {
                  const playPromise = audio.play();
                  if (playPromise !== undefined) {
                      playPromise.catch(() => {
                         console.log('自动播放被阻止');
                      });
                  }
              }
        
        // 定期保存播放进度
              setInterval(() => {
                 if (!audio.paused) {
                     sessionStorage.setItem('musicCurrentTime', audio.currentTime);
                 }
              }, 1000);
        
        // 页面卸载前保存当前播放时间
              window.addEventListener('beforeunload', () => {
                 sessionStorage.setItem('musicCurrentTime', audio.currentTime);
              });
           })
           .catch(error => {
              console.error('加载音乐配置失败:', error);
        // 使用默认音乐
              const audio = document.getElementById('bgMusic');
              audio.innerHTML = '<source src="https://music.163.com/song/media/outer/url?id=1413464902.mp3" type="audio/mpeg">';
              audio.load();
              audio.play();
           });
        
        document.addEventListener('DOMContentLoaded', function() {
            // 页面元素
            const page1 = document.getElementById('page1');
            const page2 = document.getElementById('page2');
            const page3 = document.getElementById('page3');
            
            // 第一页元素
            const nameInput = document.getElementById('nameInput');
            const submitBtn = document.getElementById('submitBtn');
            const errorMessage = document.getElementById('errorMessage');
            
            // 第二页元素
            const nameDisplay = document.getElementById('nameDisplay');
            
            // 第三页元素
            const greetingContainer = document.getElementById('greetingContainer');
            const friendName = document.getElementById('friendName');
            const newYearText = document.getElementById('newYearText');
            const statementDisplay = document.getElementById('statementDisplay');
            const statementContent = document.getElementById('statementContent');
            const bgMusic = document.getElementById('bgMusic');
            
            // 状态变量
            let currentName = '';
            let musicPlayed = false;
            
            // 三种特效类型
            const effects = [
                { name: '渐变色彩', class: 'gradient-effect' },
                { name: '弹跳效果', class: 'bounce-effect' },
                { name: '彩虹效果', class: 'rainbow-effect' }
            ];
            
            // 通用祝福语
            const genericGreeting = "元旦快乐！愿新年为你带来无尽的喜悦与成功，愿你的每一天都充满阳光与欢笑！";
            
            // 姓名与对应语句的数据
            const statementsData = {
                "贺丹玲": "上元节快乐!",
                "周敏毅": "元辰启瑞，岁序更新。吾儿如光头强，当护林守正；似青松，须傲雪而立。若效达摩，必踢云破壁，勇者无畏！父望汝以「巧思破局」为楫，以「真言·心经」为帆，新岁安康，伐木成林，步履铿锵，勇夺「森林勋章」，名震「狗熊岭」；更期如金莲踏浪，似狮舞震峡谷，终成「天选之人」，王者加冕！",
                "徐宇航": "新元启，阿离伞舞映流光；岁序转，花信风携少年狂。愿君如红叶翩跹破霜寒，似纸鸢扶摇入云长。以「芳华」为笔绘山河，以「初心」为锚定星芒。元旦安康，且看峡谷花开处，尽是凌云志未央！",
                "王翔": "维公元二〇二X年元日，谨祝王翔君曰：\n元辰肇启，瑞气盈寰。值此新岁，愿君如朝阳初升，辉光日新；似鲲鹏振翼，志凌霄汉。昔年砥柱中流，协谋克艰；今岁砺戈秣马，再拓宏图。三江汇流，以成其势；众志成城，以就其功。愿君怀瑾握瑜，德才并砺；率我同仁，协契如磐。战术精研，若棋局运筹；协同无间，似战阵合一。使三角洲之名，如北斗悬天，指引方遒；如战旗猎猎，威震八荒。",
                "周旭": "元日启新，瑞霭盈门。\n贺周旭君：  \n昔岁无畏，契结英魂；  \n今岁砺锋，再战乾坤。  \n战术如渊，莫测深浅；  \n勇毅似火，焚尽荆棘。  \n愿君怀璧其德，率众如龙；  \n使契约之名，耀若辰星。  \n新岁安康，诸事顺遂；  \n鹏程万里，共赴荣光！",
                "都俊琦": "都俊琦卿，元旦安康！愿两情缱绻，朝朝暮暮，相濡以沫，岁岁常相伴，甜蜜永绵长。",
                "刘子山": "元日贺子山兄：\n岁启新元，愿君如芝兰清雅，才学日进；似青松凌云，志气长青。学业精，体康健，情谊长，共赴锦程！",
                "丁瑞绵": "祝丁瑞绵与眷侣：\n岁启新元，愿卿与君，若莲同池，不语而香；似云共天，无言而远。朝暮之间，心手相牵；风雨之际，情意自暖。新岁安宁，旧缘愈柔；愿此情如月，常圆不缺；此生如诗，细水长流。"
            };
            
            // 烟花系统相关变量
            let fireworksSystem = null;
            let fireworksAnimationId = null;
            let isAutoFiring = false;
            let autoFireInterval = null;
            
            // 音乐播放控制
            function playBackgroundMusic() {
                if (musicPlayed) return;
                
                try {
                    bgMusic.volume = 0.3; // 设置合适的音量
                    bgMusic.currentTime = 0; // 从头开始播放
                    
                    // 尝试播放音乐
                    const playPromise = bgMusic.play();
                    
                    if (playPromise !== undefined) {
                        playPromise.then(() => {
                            // 播放成功
                            musicPlayed = true;
                            console.log("音乐播放成功");
                        }).catch(error => {
                            console.log("自动播放被阻止，需要用户交互:", error);
                            
                            // 添加页面点击事件来重新尝试播放
                            const playOnClick = function() {
                                bgMusic.play().then(() => {
                                    musicPlayed = true;
                                    console.log("音乐点击后播放成功");
                                    document.removeEventListener('click', playOnClick);
                                    document.removeEventListener('touchstart', playOnClick);
                                }).catch(e => {
                                    console.log("点击后播放仍然失败:", e);
                                });
                            };
                            
                            document.addEventListener('click', playOnClick);
                            document.addEventListener('touchstart', playOnClick);
                        });
                    }
                } catch (error) {
                    console.error("播放音乐失败:", error);
                }
            }
            
            // 提前预加载音乐（在用户交互时）
            function preloadMusic() {
                try {
                    bgMusic.load();
                    console.log("音乐预加载完成");
                } catch (error) {
                    console.log("音乐预加载失败:", error);
                }
            }
            
            // 提交名字函数
            function submitName() {
                const name = nameInput.value.trim();
                
                // 检查输入是否为空
                if (name === '') {
                    // 显示错误提示
                    errorMessage.classList.add('show');
                    
                    // 3秒后隐藏错误提示
                    setTimeout(() => {
                        errorMessage.classList.remove('show');
                    }, 3000);
                    
                    return;
                }
                
                // 隐藏错误提示（如果有）
                errorMessage.classList.remove('show');
                
                // 保存名字
                currentName = name;
                
                // 预加载音乐（在用户交互时）
                preloadMusic();
                
                // 切换到名字展示页面
                showPage2();
            }
            
            // 显示第二页（名字展示页面）
            function showPage2() {
                // 隐藏第一页
                page1.classList.add('hidden');
                
                // 显示第二页
                setTimeout(() => {
                    page2.classList.add('active');
                    
                    // 开始名字展示动画
                    showNameDisplay();
                }, 500);
            }
            
            // 显示名字展示动画
            function showNameDisplay() {
                // 随机选择一种特效
                const randomEffect = effects[Math.floor(Math.random() * effects.length)];
                
                // 清空名字显示区域
                nameDisplay.innerHTML = '';
                
                // 第一阶段：逐个字符放大显示
                const chars = currentName.split('');
                chars.forEach((char, index) => {
                    const charSpan = document.createElement('span');
                    charSpan.className = 'name-char scale-up-char';
                    charSpan.textContent = char;
                    
                    // 设置每个字符的延迟，间隔1秒
                    charSpan.style.animationDelay = `${index * 1}s`;
                    
                    nameDisplay.appendChild(charSpan);
                });
                
                // 计算第一阶段完成时间（所有字符显示完成后）
                const firstStageCompleteTime = chars.length * 1000 + 500;
                
                // 第一阶段完成后，开始第二阶段
                setTimeout(() => {
                    // 移除第一阶段动画类
                    const charElements = nameDisplay.querySelectorAll('.name-char');
                    charElements.forEach(charElement => {
                        charElement.classList.remove('scale-up-char');
                        // 清除动画延迟
                        charElement.style.animationDelay = '';
                        
                        // 添加整体特效应用动画
                        charElement.classList.add('whole-effect-apply');
                    });
                    
                    // 短暂延迟后应用随机特效
                    setTimeout(() => {
                        // 移除整体特效应用动画
                        charElements.forEach(charElement => {
                            charElement.classList.remove('whole-effect-apply');
                            // 添加随机特效类
                            charElement.classList.add(randomEffect.class);
                        });
                        
                        // 特效显示2秒后，停顿1秒，然后切换到元旦快乐页面
                        setTimeout(() => {
                            // 隐藏第二页
                            page2.classList.remove('active');
                            
                            // 显示第三页
                            setTimeout(() => {
                                showPage3();
                            }, 1000); // 停顿1秒
                        }, 2000); // 特效显示2秒
                        
                    }, 800); // 等待整体特效应用动画完成
                    
                }, firstStageCompleteTime);
            }
            
            // 显示第三页（烟花和元旦快乐页面）
            function showPage3() {
                page3.classList.add('active');
                
                // 播放背景音乐
                setTimeout(() => {
                    playBackgroundMusic();
                }, 500);
                
                // 开始烟花系统
                initFireworksSystem();
                
                // 开始元旦快乐动画
                showNewYearGreeting();
            }
            
            // 显示元旦快乐动画
            function showNewYearGreeting() {
                // 清空显示区域
                friendName.textContent = '';
                greetingContainer.classList.remove('active');
                statementContent.innerHTML = '';
                statementDisplay.classList.remove('active');
                
                // 显示朋友的名字
                if (currentName && currentName.trim() !== '') {
                    friendName.textContent = currentName ;
                } else {
                    friendName.textContent = '朋友';
                }
                
                // 显示问候区域
                greetingContainer.classList.add('active');
                
                // 元旦快乐动画完成后2秒，开始显示个性化语句或通用祝福语
                setTimeout(() => {
                    // 添加元旦快乐文字消失动画
                    greetingContainer.classList.add('fade-out');
                    
                    // 1秒后隐藏元旦快乐文字，显示个性化语句或通用祝福语
                    setTimeout(() => {
                        // 显示祝福语（个性化或通用）
                        showGreetingStatement();
                    }, 1000);
                }, 5000); // 显示5秒后
            }
            
            // 显示祝福语
            function showGreetingStatement() {
                // 查找对应名字的语句
                let statement = statementsData[currentName];
                
                // 如果没有找到对应语句，则使用通用祝福语
                if (!statement) {
                    statement = genericGreeting;
                }
                
                // 将语句显示在语句区域
                statementContent.innerHTML = '';
                
                // 将语句按换行分割并添加段落
                const lines = statement.split('\n');
                lines.forEach(line => {
                    if (line.trim()) {
                        const p = document.createElement('p');
                        p.textContent = line;
                        p.style.marginBottom = '20px';
                        statementContent.appendChild(p);
                    } else {
                        statementContent.appendChild(document.createElement('br'));
                    }
                });
                
                // 隐藏问候区域，显示语句区域
                greetingContainer.style.display = 'none';
                statementDisplay.classList.add('active');
                
                // 不再设置返回第一页的定时器，会一直停留在当前页面
            }
            
            // 烟花系统函数
            function initFireworksSystem() {
                const canvas = document.getElementById('fireworksCanvas');
                const ctx = canvas.getContext('2d', { alpha: true });
                
                function resizeCanvas() {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                }
                
                resizeCanvas();
                
                // 性能优化：防抖处理resize事件
                let resizeTimeout;
                window.addEventListener('resize', function() {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(resizeCanvas, 100);
                });
                
                let fireworks = [];
                let particles = [];
                let heartExplosions = [];
                let lastFireworkTime = 0;
                
                // 检测是否为移动端
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 768;
                const particleMultiplier = isMobile ? 0.6 : 1;
                
                // 使用requestAnimationFrame自动适配帧率
                let lastTime = 0;
                
                // 物理参数 - 高度真实感调优
                const GRAVITY = 0.15;
                const EXPLOSION_HEIGHT_RATIO = 0.55;
                const WIND = 0.018;
                const AIR_RESISTANCE = 0.97;
                
                // 颜色预设
                const COLOR_PRESETS = [
                    // 主色调
                    {hue: 0, saturation: 100, lightness: 75, type: 'single'},
                    {hue: 30, saturation: 100, lightness: 75, type: 'single'},
                    {hue: 60, saturation: 100, lightness: 75, type: 'single'},
                    {hue: 120, saturation: 100, lightness: 75, type: 'single'},
                    {hue: 180, saturation: 100, lightness: 75, type: 'single'},
                    {hue: 240, saturation: 100, lightness: 75, type: 'single'},
                    {hue: 270, saturation: 100, lightness: 75, type: 'single'},
                    {hue: 300, saturation: 100, lightness: 75, type: 'single'},
                    {hue: 330, saturation: 100, lightness: 75, type: 'single'},
                    
                    // 渐变色调
                    {hue: 15, saturation: 100, lightness: 70, type: 'gradient'},
                    {hue: 180, saturation: 100, lightness: 65, type: 'gradient'},
                    {hue: 280, saturation: 100, lightness: 70, type: 'gradient'},
                    {hue: 90, saturation: 100, lightness: 65, type: 'gradient'},
                    
                    // 彩菊型专用颜色
                    {hue: 0, saturation: 100, lightness: 70, type: 'chrysanthemum'},
                    {hue: 30, saturation: 100, lightness: 70, type: 'chrysanthemum'},
                    {hue: 60, saturation: 100, lightness: 70, type: 'chrysanthemum'},
                    {hue: 90, saturation: 100, lightness: 70, type: 'chrysanthemum'},
                    {hue: 120, saturation: 100, lightness: 70, type: 'chrysanthemum'},
                    {hue: 150, saturation: 100, lightness: 70, type: 'chrysanthemum'},
                    {hue: 180, saturation: 100, lightness: 70, type: 'chrysanthemum'},
                    {hue: 210, saturation: 100, lightness: 70, type: 'chrysanthemum'},
                    {hue: 240, saturation: 100, lightness: 70, type: 'chrysanthemum'},
                    {hue: 270, saturation: 100, lightness: 70, type: 'chrysanthemum'},
                    {hue: 300, saturation: 100, lightness: 70, type: 'chrysanthemum'},
                    {hue: 330, saturation: 100, lightness: 70, type: 'chrysanthemum'},
                ];
                
                // 爆炸模式分类
                const EXPLOSION_PATTERNS = {
                    CIRCLE: 'circle',
                    SPARKLE: 'sparkle',
                    VORTEX: 'vortex',
                    RAINBOW: 'rainbow',
                    RING: 'ring',
                    SUN: 'sun',
                    BURST: 'burst',
                    CASCADE: 'cascade',
                    HEART: 'heart',
                    METEOR_SHOWER: 'meteor_shower',
                    FIRE_TREE: 'fire_tree',
                    ELLIPSE: 'ellipse',
                    CHRYSANTHEMUM: 'chrysanthemum',
                    PARAMETRIC_CIRCLE: 'parametric_circle',
                    PARAMETRIC_ELLIPSE: 'parametric_ellipse',
                    PARAMETRIC_STAR: 'parametric_star',
                    SPIRAL_PARAMETRIC: 'spiral_parametric'
                };
                
                // 简化随机函数
                const random = (min, max) => Math.random() * (max - min) + min;
                const randomInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
                
                // 随机爆炸模式选择
                function getRandomExplosionPattern() {
                    const weightedPatterns = [];
                    
                    // 普通烟花模式：20%
                    const normalPatterns = [
                        EXPLOSION_PATTERNS.CIRCLE,
                        EXPLOSION_PATTERNS.SPARKLE,
                        EXPLOSION_PATTERNS.VORTEX,
                        EXPLOSION_PATTERNS.RAINBOW,
                        EXPLOSION_PATTERNS.RING,
                        EXPLOSION_PATTERNS.SUN,
                        EXPLOSION_PATTERNS.BURST,
                        EXPLOSION_PATTERNS.CASCADE
                    ];
                    
                    const counts = [6, 6, 6, 6, 6, 5, 5, 5];
                    
                    for (let i = 0; i < normalPatterns.length; i++) {
                        for (let j = 0; j < counts[i]; j++) {
                            weightedPatterns.push(normalPatterns[i]);
                        }
                    }
                    
                    // 参数方程模式：40%
                    for (let i = 0; i < 54; i++) weightedPatterns.push(EXPLOSION_PATTERNS.PARAMETRIC_CIRCLE);
                    for (let i = 0; i < 18; i++) weightedPatterns.push(EXPLOSION_PATTERNS.PARAMETRIC_ELLIPSE);
                    for (let i = 0; i < 14; i++) weightedPatterns.push(EXPLOSION_PATTERNS.PARAMETRIC_STAR);
                    for (let i = 0; i < 4; i++) weightedPatterns.push(EXPLOSION_PATTERNS.SPIRAL_PARAMETRIC);
                    
                    // 特殊烟花模式：40%
                    for (let i = 0; i < 27; i++) weightedPatterns.push(EXPLOSION_PATTERNS.HEART);
                    for (let i = 0; i < 18; i++) weightedPatterns.push(EXPLOSION_PATTERNS.METEOR_SHOWER);
                    for (let i = 0; i < 11; i++) weightedPatterns.push(EXPLOSION_PATTERNS.FIRE_TREE);
                    for (let i = 0; i < 7; i++) weightedPatterns.push(EXPLOSION_PATTERNS.ELLIPSE);
                    for (let i = 0; i < 27; i++) weightedPatterns.push(EXPLOSION_PATTERNS.CHRYSANTHEMUM);
                    
                    return weightedPatterns[randomInt(0, weightedPatterns.length - 1)];
                }
                
                // 获取随机颜色配置
                function getRandomColorConfig(pattern) {
                    if (pattern === EXPLOSION_PATTERNS.CHRYSANTHEMUM) {
                        const chrysanthemumColors = COLOR_PRESETS.filter(c => c.type === 'chrysanthemum');
                        return chrysanthemumColors[randomInt(0, chrysanthemumColors.length - 1)];
                    }
                    
                    const color1 = COLOR_PRESETS[randomInt(0, COLOR_PRESETS.length - 1)];
                    
                    if (Math.random() < 0.3) {
                        const color2 = COLOR_PRESETS[randomInt(0, COLOR_PRESETS.length - 1)];
                        return {
                            hue: color1.hue,
                            saturation: color1.saturation,
                            lightness: color1.lightness,
                            type: 'dual',
                            secondHue: color2.hue,
                            secondSaturation: color2.saturation,
                            secondLightness: color2.lightness
                        };
                    }
                    
                    return color1;
                }
                
                // 简化爱心爆炸管理器
                class HeartExplosionManager {
                    constructor(x, y, colorConfig, explosionPower) {
                        this.x = x;
                        this.y = y;
                        this.colorConfig = colorConfig;
                        this.explosionPower = explosionPower;
                        
                        this.createdAt = Date.now();
                        this.lifetime = 1500;
                        this.heartParticles = [];
                        
                        this.createHeartParticles();
                    }
                    
                    createHeartParticles() {
                        const baseCount = isMobile ? randomInt(70, 110) : randomInt(120, 180);
                        const particleCount = Math.floor(baseCount * particleMultiplier);
                        
                        for (let i = 0; i < particleCount; i++) {
                            const t = (i / particleCount) * Math.PI * 2;
                            
                            const sinT = Math.sin(t);
                            const cosT = Math.cos(t);
                            const cos2T = Math.cos(2 * t);
                            const cos3T = Math.cos(3 * t);
                            const cos4T = Math.cos(4 * t);
                            
                            const heartX = 16 * Math.pow(sinT, 3);
                            const heartY = 13 * cosT - 5 * cos2T - 2 * cos3T - cos4T;
                            
                            const scale = 5.5 * this.explosionPower;
                            const x = this.x + heartX * scale;
                            const y = this.y - heartY * scale;
                            
                            const heartParticle = new SimplifiedHeartParticle(
                                x, y, 
                                this.colorConfig,
                                this.explosionPower,
                                t
                            );
                            
                            this.heartParticles.push(heartParticle);
                        }
                    }
                    
                    update(deltaTime) {
                        const deltaSeconds = deltaTime / 1000;
                        const currentTime = Date.now();
                        const elapsed = currentTime - this.createdAt;
                        
                        for (let i = this.heartParticles.length - 1; i >= 0; i--) {
                            this.heartParticles[i].update(deltaTime, elapsed);
                        }
                        
                        return elapsed < this.lifetime;
                    }
                    
                    draw(ctx) {
                        for (const heartParticle of this.heartParticles) {
                            heartParticle.draw(ctx);
                        }
                    }
                }
                
                // 简化爱心粒子类
                class SimplifiedHeartParticle {
                    constructor(x, y, colorConfig, explosionPower, phase) {
                        this.x = x;
                        this.y = y;
                        this.originalX = x;
                        this.originalY = y;
                        this.colorConfig = colorConfig;
                        this.explosionPower = explosionPower;
                        this.phase = phase;
                        
                        this.baseSize = random(1.5, 2.5);
                        this.currentSize = this.baseSize;
                        this.life = 1.0;
                        
                        this.t = phase;
                        this.scale = 5.5 * this.explosionPower;
                        
                        this.updatePositionFromParametric();
                        
                        this.hue = colorConfig.hue;
                        this.saturation = colorConfig.saturation;
                        this.lightness = colorConfig.lightness;
                        
                        this.twinkleSpeed = random(0.8, 1.5);
                        this.twinklePhase = random(0, Math.PI * 2);
                        this.twinkleAmount = random(0.1, 0.2);
                    }
                    
                    updatePositionFromParametric() {
                        const sinT = Math.sin(this.t);
                        const cosT = Math.cos(this.t);
                        const cos2T = Math.cos(2 * this.t);
                        const cos3T = Math.cos(3 * this.t);
                        const cos4T = Math.cos(4 * this.t);
                        
                        const heartX = 16 * Math.pow(sinT, 3);
                        const heartY = 13 * cosT - 5 * cos2T - 2 * cos3T - cos4T;
                        
                        this.x = this.originalX + heartX * this.scale;
                        this.y = this.originalY - heartY * this.scale;
                    }
                    
                    update(deltaTime, elapsed) {
                        const deltaSeconds = deltaTime / 1000;
                        
                        this.life = Math.max(0, 1 - elapsed / 1500);
                        
                        if (Math.random() < 0.3) {
                            this.x += random(-0.8, 0.8);
                            this.y += random(-0.8, 0.8);
                        }
                        
                        const twinkle = Math.sin(Date.now() * 0.001 * this.twinkleSpeed + this.twinklePhase) * this.twinkleAmount;
                        this.currentSize = this.baseSize * (1 + twinkle) * this.life;
                        
                        return this.life > 0;
                    }
                    
                    draw(ctx) {
                        const alpha = this.life * 0.9;
                        
                        let hue, saturation, lightness;
                        
                        if (this.colorConfig.type === 'dual' && Math.random() > 0.5) {
                            hue = this.colorConfig.secondHue || this.colorConfig.hue;
                            saturation = this.colorConfig.secondSaturation || this.colorConfig.saturation;
                            lightness = this.colorConfig.secondLightness || this.colorConfig.lightness;
                        } else {
                            hue = this.hue;
                            saturation = this.saturation;
                            lightness = this.lightness;
                        }
                        
                        const color = `hsla(${hue}, ${saturation}%, ${lightness}%, ${alpha})`;
                        
                        ctx.fillStyle = color;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.currentSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                // 流星类
                class Meteor {
                    constructor(x, y, colorConfig) {
                        this.x = x;
                        this.y = y;
                        this.colorConfig = colorConfig;
                        
                        this.size = random(1.8, 3.7);
                        this.length = random(18, 36);
                        this.speed = random(280, 550);
                        this.angle = random(-Math.PI/8, Math.PI/8);
                        this.life = 1.0;
                        this.decayRate = random(0.085, 0.22);
                        
                        this.vx = Math.sin(this.angle) * this.speed;
                        this.vy = Math.cos(this.angle) * this.speed;
                        
                        this.createdAt = Date.now();
                        
                        this.trailParticles = [];
                        this.lastTrailTime = 0;
                        this.fadeFactor = 1.5;
                    }
                    
                    update(deltaTime) {
                        const deltaSeconds = deltaTime / 1000;
                        const currentTime = Date.now();
                        
                        this.x += this.vx * deltaSeconds;
                        this.y += this.vy * deltaSeconds;
                        
                        this.vy += GRAVITY * 0.75 * deltaSeconds;
                        this.vx += WIND * random(-0.04, 0.04) * deltaSeconds;
                        
                        this.vx *= Math.pow(AIR_RESISTANCE, deltaSeconds * 60);
                        this.vy *= Math.pow(AIR_RESISTANCE, deltaSeconds * 60);
                        
                        this.life -= this.decayRate * deltaSeconds;
                        
                        if (currentTime - this.lastTrailTime > 22) {
                            this.trailParticles.push(new MeteorTrailParticle(
                                this.x,
                                this.y,
                                this.colorConfig
                            ));
                            this.lastTrailTime = currentTime;
                        }
                        
                        for (let i = this.trailParticles.length - 1; i >= 0; i--) {
                            if (!this.trailParticles[i].update(deltaTime)) {
                                this.trailParticles.splice(i, 1);
                            }
                        }
                        
                        if (this.trailParticles.length > (isMobile ? 15 : 25)) {
                            this.trailParticles.splice(0, this.trailParticles.length - (isMobile ? 12 : 20));
                        }
                        
                        return this.life > 0 && this.y < canvas.height + 45;
                    }
                    
                    draw(ctx) {
                        const alpha = Math.max(0, 1 - (1 - this.life) * this.fadeFactor) * 0.85;
                        const color = `hsla(${this.colorConfig.hue}, ${this.colorConfig.saturation}%, ${this.colorConfig.lightness}%, ${alpha})`;
                        
                        ctx.fillStyle = color;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                        ctx.fill();
                        
                        const gradient = ctx.createLinearGradient(
                            this.x, this.y,
                            this.x - Math.sin(this.angle) * this.length,
                            this.y - Math.cos(this.angle) * this.length
                        );
                        
                        gradient.addColorStop(0, `hsla(${this.colorConfig.hue}, ${this.colorConfig.saturation}%, ${this.colorConfig.lightness}%, ${alpha})`);
                        gradient.addColorStop(0.5, `hsla(${this.colorConfig.hue}, ${this.colorConfig.saturation}%, ${this.colorConfig.lightness}%, ${alpha * 0.45})`);
                        gradient.addColorStop(1, `hsla(${this.colorConfig.hue}, ${this.colorConfig.saturation}%, ${this.colorConfig.lightness}%, 0)`);
                        
                        ctx.strokeStyle = gradient;
                        ctx.lineWidth = this.size * 0.75;
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y);
                        ctx.lineTo(
                            this.x - Math.sin(this.angle) * this.length,
                            this.y - Math.cos(this.angle) * this.length
                        );
                        ctx.stroke();
                        
                        for (const trailParticle of this.trailParticles) {
                            trailParticle.draw(ctx);
                        }
                    }
                }
                
                // 流星轨迹粒子类
                class MeteorTrailParticle {
                    constructor(x, y, colorConfig) {
                        this.x = x;
                        this.y = y;
                        this.colorConfig = colorConfig;
                        
                        this.size = random(0.9, 2.3);
                        this.life = 1.0;
                        this.decayRate = random(0.055, 0.18);
                        
                        this.vx = random(-8, 8);
                        this.vy = random(-8, 8);
                        
                        this.fadeFactor = 1.5;
                    }
                    
                    update(deltaTime) {
                        const deltaSeconds = deltaTime / 1000;
                        
                        this.x += this.vx * deltaSeconds;
                        this.y += this.vy * deltaSeconds;
                        
                        this.vy += GRAVITY * 0.25 * deltaSeconds;
                        
                        this.vx *= Math.pow(AIR_RESISTANCE, deltaSeconds * 60);
                        this.vy *= Math.pow(AIR_RESISTANCE, deltaSeconds * 60);
                        
                        this.life -= this.decayRate * deltaSeconds;
                        
                        return this.life > 0;
                    }
                    
                    draw(ctx) {
                        const alpha = Math.max(0, 1 - (1 - this.life) * this.fadeFactor) * 0.55;
                        const color = `hsla(${this.colorConfig.hue}, ${this.colorConfig.saturation}%, ${this.colorConfig.lightness}%, ${alpha})`;
                        
                        ctx.fillStyle = color;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                // 火树银花粒子类
                class FireTreeParticle {
                    constructor(x, y, colorConfig) {
                        this.x = x;
                        this.y = y;
                        this.colorConfig = colorConfig;
                        
                        this.baseSize = random(1.6, 3.2);
                        this.currentSize = this.baseSize;
                        this.life = 1.0;
                        this.decayRate = random(0.01, 0.03);
                        
                        this.twinkleSpeed = random(1.1, 2.8);
                        this.twinklePhase = random(0, Math.PI * 2);
                        this.twinkleAmount = random(0.25, 0.55);
                        
                        this.phase = 1;
                        this.phaseDuration = random(0.9, 2.0);
                        this.phaseTime = 0;
                        
                        const angle = random(-Math.PI, Math.PI);
                        const speed = random(110, 330);
                        this.vx = Math.cos(angle) * speed * 0.65;
                        this.vy = Math.sin(angle) * speed - 140;
                        
                        this.fallSpeed = random(25, 90);
                        this.swingAmount = random(18, 55);
                        this.swingSpeed = random(1.1, 3.2);
                        this.swingPhase = random(0, Math.PI * 2);
                        
                        this.sparkParticles = [];
                        this.lastSparkTime = 0;
                        
                        this.createdAt = Date.now();
                        this.fadeFactor = 1.5;
                    }
                    
                    update(deltaTime) {
                        const deltaSeconds = deltaTime / 1000;
                        const currentTime = Date.now();
                        this.phaseTime += deltaSeconds;
                        
                        if (this.phase === 1) {
                            this.x += this.vx * deltaSeconds;
                            this.y += this.vy * deltaSeconds;
                            
                            this.vy += GRAVITY * 0.18 * deltaSeconds;
                            this.vx += WIND * random(-0.018, 0.018) * deltaSeconds;
                            
                            this.vx *= Math.pow(AIR_RESISTANCE, deltaSeconds * 60);
                            this.vy *= Math.pow(AIR_RESISTANCE, deltaSeconds * 60);
                            
                            if (currentTime - this.lastSparkTime > 45) {
                                this.sparkParticles.push(new FireTreeSpark(
                                    this.x + random(-2.5, 2.5),
                                    this.y + random(-2.5, 2.5),
                                    this.colorConfig
                                ));
                                this.lastSparkTime = currentTime;
                            }
                            
                            if (this.phaseTime > this.phaseDuration) {
                                this.phase = 2;
                                this.vx = random(-18, 18);
                                this.vy = this.fallSpeed;
                            }
                        } else {
                            this.x += this.vx * deltaSeconds;
                            this.y += this.vy * deltaSeconds;
                            
                            const swing = Math.sin(currentTime * 0.001 * this.swingSpeed + this.swingPhase) * this.swingAmount * deltaSeconds;
                            this.x += swing;
                            
                            this.vy += GRAVITY * 0.65 * deltaSeconds;
                            this.vx += WIND * random(-0.009, 0.009) * deltaSeconds;
                            
                            this.vx *= Math.pow(AIR_RESISTANCE, deltaSeconds * 60);
                            
                            if (currentTime - this.lastSparkTime > 110) {
                                this.sparkParticles.push(new FireTreeSpark(
                                    this.x + random(-1.8, 1.8),
                                    this.y + random(-1.8, 1.8),
                                    this.colorConfig
                                ));
                                this.lastSparkTime = currentTime;
                            }
                        }
                        
                        this.life -= this.decayRate * deltaSeconds;
                        
                        const twinkle = Math.sin(currentTime * 0.001 * this.twinkleSpeed + this.twinklePhase) * this.twinkleAmount;
                        this.currentSize = this.baseSize * (1 + twinkle) * this.life;
                        
                        for (let i = this.sparkParticles.length - 1; i >= 0; i--) {
                            if (!this.sparkParticles[i].update(deltaTime)) {
                                this.sparkParticles.splice(i, 1);
                            }
                        }
                        
                        if (this.sparkParticles.length > (isMobile ? 8 : 12)) {
                            this.sparkParticles.splice(0, this.sparkParticles.length - (isMobile ? 6 : 10));
                        }
                        
                        return this.life > 0 && this.y < canvas.height + 70;
                    }
                    
                    draw(ctx) {
                        for (const spark of this.sparkParticles) {
                            spark.draw(ctx);
                        }
                        
                        const alpha = Math.max(0, 1 - (1 - this.life) * this.fadeFactor) * 0.85;
                        let color;
                        
                        if (this.colorConfig.type === 'silver' || this.colorConfig.type === 'light_silver') {
                            const brightness = 88 + Math.sin(Date.now() * 0.0018) * 8;
                            color = `hsla(${this.colorConfig.hue}, ${this.colorConfig.saturation}%, ${brightness}%, ${alpha})`;
                        } else if (this.colorConfig.type === 'gold' || this.colorConfig.type === 'light_gold') {
                            const brightness = 78 + Math.sin(Date.now() * 0.0025) * 12;
                            color = `hsla(${this.colorConfig.hue}, ${this.colorConfig.saturation}%, ${brightness}%, ${alpha})`;
                        } else {
                            const brightness = 93 + Math.sin(Date.now() * 0.0012) * 4;
                            color = `hsla(${this.colorConfig.hue}, ${this.colorConfig.saturation}%, ${brightness}%, ${alpha})`;
                        }
                        
                        ctx.fillStyle = color;
                        
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.currentSize, 0, Math.PI * 2);
                        ctx.fill();
                        
                        if (this.life > 0.6) {
                            ctx.globalAlpha = alpha * 0.35;
                            ctx.fillStyle = this.colorConfig.type.includes('silver') 
                                ? 'rgba(255, 255, 255, 0.25)'
                                : this.colorConfig.type.includes('gold')
                                    ? 'rgba(255, 215, 0, 0.25)'
                                    : 'rgba(255, 255, 255, 0.25)';
                            ctx.beginPath();
                            ctx.arc(this.x, this.y, this.currentSize * 1.4, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.globalAlpha = 1.0;
                        }
                    }
                }
                
                // 火树银花火花粒子类
                class FireTreeSpark {
                    constructor(x, y, colorConfig) {
                        this.x = x;
                        this.y = y;
                        this.colorConfig = colorConfig;
                        
                        this.size = random(0.7, 1.9);
                        this.life = 1.0;
                        this.decayRate = random(0.18, 0.38);
                        
                        this.vx = random(-18, 18);
                        this.vy = random(-18, 18);
                        
                        this.fadeFactor = 1.5;
                    }
                    
                    update(deltaTime) {
                        const deltaSeconds = deltaTime / 1000;
                        
                        this.x += this.vx * deltaSeconds;
                        this.y += this.vy * deltaSeconds;
                        
                        this.vy += GRAVITY * 0.4 * deltaSeconds;
                        
                        this.vx *= Math.pow(0.88, deltaSeconds * 60);
                        this.vy *= Math.pow(0.88, deltaSeconds * 60);
                        
                        this.life -= this.decayRate * deltaSeconds;
                        
                        return this.life > 0;
                    }
                    
                    draw(ctx) {
                        const alpha = Math.max(0, 1 - (1 - this.life) * this.fadeFactor) * 0.65;
                        let color;
                        
                        if (this.colorConfig.type === 'silver' || this.colorConfig.type === 'light_silver') {
                            color = `hsla(${this.colorConfig.hue}, ${this.colorConfig.saturation}%, 92%, ${alpha})`;
                        } else if (this.colorConfig.type === 'gold' || this.colorConfig.type === 'light_gold') {
                            color = `hsla(${this.colorConfig.hue}, ${this.colorConfig.saturation}%, 87%, ${alpha})`;
                        } else {
                            color = `hsla(${this.colorConfig.hue}, ${this.colorConfig.saturation}%, 92%, ${alpha})`;
                        }
                        
                        ctx.fillStyle = color;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                // 彩菊型粒子类
                class ChrysanthemumParticle {
                    constructor(x, y, colorConfig, explosionPower = 1) {
                        this.x = x;
                        this.y = y;
                        this.colorConfig = colorConfig;
                        this.explosionPower = explosionPower;
                        
                        this.baseSize = random(1.1, 2.2);
                        this.currentSize = this.baseSize;
                        this.life = 1.0;
                        this.decayRate = random(0.085, 0.22);
                        
                        this.hueShift = random(-18, 18);
                        this.originalHue = colorConfig.hue;
                        
                        const angle = random(0, Math.PI * 2);
                        const speed = random(165, 320) * explosionPower;
                        this.vx = Math.cos(angle) * speed;
                        this.vy = Math.sin(angle) * speed;
                        
                        this.curveFactor = random(0.25, 0.85);
                        this.curveTime = 0;
                        
                        this.isFireSpark = true;
                        this.fireSparkDuration = random(0.12, 0.28);
                        this.colorMixRatio = 0;
                        this.colorMixSpeed = random(0.55, 1.1);
                        
                        this.sparkleFactor = random(0.22, 0.42);
                        this.sparklePhase = random(0, Math.PI * 2);
                        
                        this.createdAt = Date.now();
                        
                        this.tailParticles = [];
                        this.fadeFactor = 1.5;
                    }
                    
                    update(deltaTime) {
                        const deltaSeconds = deltaTime / 1000;
                        this.curveTime += deltaSeconds;
                        
                        this.x += this.vx * deltaSeconds;
                        this.y += this.vy * deltaSeconds;
                        
                        const curve = Math.sin(this.curveTime * 0.0025) * this.curveFactor;
                        this.vx += curve * deltaSeconds * 35;
                        this.vy += curve * deltaSeconds * 35;
                        
                        this.vy += GRAVITY * 0.55 * deltaSeconds;
                        this.vx += WIND * random(-0.025, 0.025) * deltaSeconds;
                        
                        this.vx *= Math.pow(AIR_RESISTANCE, deltaSeconds * 60);
                        this.vy *= Math.pow(AIR_RESISTANCE, deltaSeconds * 60);
                        
                        this.life -= this.decayRate * deltaSeconds;
                        
                        const aliveTime = (Date.now() - this.createdAt) / 1000;
                        if (this.isFireSpark && aliveTime > this.fireSparkDuration) {
                            this.isFireSpark = false;
                        }
                        
                        if (!this.isFireSpark && this.colorMixRatio < 1) {
                            this.colorMixRatio = Math.min(1, this.colorMixRatio + this.colorMixSpeed * deltaSeconds);
                        }
                        
                        this.currentSize = this.baseSize * this.life;
                        
                        if (this.sparkleFactor > 0) {
                            this.currentSize *= 1 + Math.sin(Date.now() * 0.007 + this.sparklePhase) * this.sparkleFactor;
                        }
                        
                        if (Math.random() < (isMobile ? 0.12 : 0.18)) {
                            this.tailParticles.push(new ChrysanthemumTailParticle(
                                this.x,
                                this.y,
                                this.colorConfig,
                                this.life
                            ));
                        }
                        
                        for (let i = this.tailParticles.length - 1; i >= 0; i--) {
                            if (!this.tailParticles[i].update(deltaTime)) {
                                this.tailParticles.splice(i, 1);
                            }
                        }
                        
                        if (this.tailParticles.length > (isMobile ? 6 : 8)) {
                            this.tailParticles.splice(0, this.tailParticles.length - (isMobile ? 5 : 7));
                        }
                        
                        return this.life > 0 && this.y < canvas.height + 75;
                    }
                    
                    draw(ctx) {
                        for (const tailParticle of this.tailParticles) {
                            tailParticle.draw(ctx);
                        }
                        
                        const alpha = Math.max(0, 1 - (1 - this.life) * this.fadeFactor);
                        
                        let color;
                        if (this.isFireSpark) {
                            const brightness = 88 + Math.sin(Date.now() * 0.004) * 7;
                            color = `hsla(60, 100%, ${brightness}%, ${alpha * 0.82})`;
                        } else {
                            const hue = (this.originalHue + this.hueShift * this.colorMixRatio) % 360;
                            const saturation = this.colorConfig.saturation;
                            const lightness = 68 + (this.colorConfig.lightness - 68) * this.colorMixRatio;
                            
                            color = `hsla(${hue}, ${saturation}%, ${lightness}%, ${alpha * 0.72})`;
                        }
                        
                        ctx.fillStyle = color;
                        
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.currentSize, 0, Math.PI * 2);
                        ctx.fill();
                        
                        if (this.life > 0.5) {
                            ctx.globalAlpha = this.life * 0.22;
                            ctx.fillStyle = this.isFireSpark ? 'rgba(255, 255, 235, 0.35)' : `hsla(${this.colorConfig.hue}, 62%, 78%, 0.22)`;
                            ctx.beginPath();
                            ctx.arc(this.x, this.y, this.currentSize * 1.12, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.globalAlpha = 1.0;
                        }
                    }
                }
                
                // 彩菊型尾部粒子类
                class ChrysanthemumTailParticle {
                    constructor(x, y, colorConfig, parentLife) {
                        this.x = x;
                        this.y = y;
                        this.colorConfig = colorConfig;
                        
                        this.size = random(0.6, 1.6);
                        this.life = parentLife * random(0.45, 0.75);
                        this.decayRate = random(0.12, 0.28);
                        
                        this.vx = random(-12, 12);
                        this.vy = random(-12, 12);
                        
                        this.fadeFactor = 1.5;
                    }
                    
                    update(deltaTime) {
                        const deltaSeconds = deltaTime / 1000;
                        
                        this.x += this.vx * deltaSeconds;
                        this.y += this.vy * deltaSeconds;
                        
                        this.vy += GRAVITY * 0.35 * deltaSeconds;
                        
                        this.vx *= Math.pow(AIR_RESISTANCE, deltaSeconds * 60);
                        this.vy *= Math.pow(AIR_RESISTANCE, deltaSeconds * 60);
                        
                        this.life -= this.decayRate * deltaSeconds;
                        
                        return this.life > 0;
                    }
                    
                    draw(ctx) {
                        const alpha = Math.max(0, 1 - (1 - this.life) * this.fadeFactor) * 0.48;
                        const hue = this.colorConfig.hue;
                        const saturation = this.colorConfig.saturation;
                        const lightness = this.colorConfig.lightness;
                        
                        const color = `hsla(${hue}, ${saturation}%, ${lightness}%, ${alpha})`;
                        
                        ctx.fillStyle = color;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                // 参数方程螺旋粒子类
                class ParametricSpiralParticle {
                    constructor(x, y, colorConfig, explosionPower) {
                        this.x = x;
                        this.y = y;
                        this.colorConfig = colorConfig;
                        this.explosionPower = explosionPower;
                        
                        this.theta = random(0, Math.PI * 12);
                        this.a = random(1.5, 3.0);
                        this.angularSpeed = random(2.0, 4.0);
                        this.radialSpeed = random(80, 150) * explosionPower;
                        
                        this.baseSize = random(1.0, 2.2);
                        this.currentSize = this.baseSize;
                        this.life = 1.0;
                        this.decayRate = random(0.12, 0.25);
                        
                        this.spiralType = randomInt(0, 2);
                        
                        this.hueShift = random(-20, 20);
                        this.originalHue = colorConfig.hue;
                        
                        this.twinkleSpeed = random(2.0, 3.5);
                        this.twinklePhase = random(0, Math.PI * 2);
                        this.twinkleAmount = random(0.15, 0.3);
                        
                        this.createdAt = Date.now();
                        this.fadeFactor = 1.5;
                    }
                    
                    update(deltaTime) {
                        const deltaSeconds = deltaTime / 1000;
                        const currentTime = Date.now();
                        
                        this.theta += this.angularSpeed * deltaSeconds;
                        
                        let r;
                        switch (this.spiralType) {
                            case 0:
                                r = this.a * this.theta;
                                break;
                            case 1:
                                r = this.a * Math.sqrt(Math.abs(this.theta));
                                break;
                            case 2:
                                r = this.a / (Math.max(0.1, Math.abs(this.theta)));
                                break;
                            default:
                                r = this.a * this.theta;
                        }
                        
                        const newX = this.x + Math.cos(this.theta) * r;
                        const newY = this.y + Math.sin(this.theta) * r;
                        
                        this.vx = (newX - this.x) / deltaSeconds;
                        this.vy = (newY - this.y) / deltaSeconds;
                        
                        this.x = newX;
                        this.y = newY;
                        
                        this.vy += GRAVITY * 0.3 * deltaSeconds;
                        
                        this.life -= this.decayRate * deltaSeconds;
                        
                        const twinkle = Math.sin(currentTime * 0.001 * this.twinkleSpeed + this.twinklePhase) * this.twinkleAmount;
                        this.currentSize = this.baseSize * (1 + twinkle) * this.life;
                        
                        const radiusFactor = Math.min(2.0, r / 100);
                        this.currentSize *= (1 + radiusFactor * 0.3);
                        
                        return this.life > 0 && this.y < canvas.height + 90;
                    }
                    
                    draw(ctx) {
                        const alpha = Math.max(0, 1 - (1 - this.life) * this.fadeFactor) * 0.85;
                        
                        const hue = (this.originalHue + this.hueShift + this.theta * 20) % 360;
                        const saturation = this.colorConfig.saturation;
                        const lightness = this.colorConfig.lightness + Math.sin(this.theta) * 5;
                        
                        const color = `hsla(${hue}, ${saturation}%, ${lightness}%, ${alpha})`;
                        
                        ctx.fillStyle = color;
                        
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.currentSize, 0, Math.PI * 2);
                        ctx.fill();
                        
                        if (this.life > 0.6) {
                            ctx.globalAlpha = alpha * 0.3;
                            ctx.fillStyle = `hsla(${hue}, ${saturation}%, ${lightness + 15}%, 0.3)`;
                            ctx.beginPath();
                            ctx.arc(this.x, this.y, this.currentSize * 1.5, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.globalAlpha = 1.0;
                        }
                        
                        if (this.life > 0.8 && Math.random() < 0.3) {
                            ctx.strokeStyle = `hsla(${hue}, ${saturation}%, ${lightness}%, ${alpha * 0.2})`;
                            ctx.lineWidth = this.currentSize * 0.5;
                            ctx.lineCap = 'round';
                            ctx.beginPath();
                            ctx.moveTo(this.x, this.y);
                            ctx.lineTo(
                                this.x - this.vx * 0.02,
                                this.y - this.vy * 0.02
                            );
                            ctx.stroke();
                        }
                    }
                }
                
                // 普通粒子类
                class Particle {
                    constructor(x, y, colorConfig, explosionPower = 1, explosionPattern = 'circle') {
                        this.x = x;
                        this.y = y;
                        this.colorConfig = colorConfig;
                        this.explosionPower = explosionPower;
                        this.explosionPattern = explosionPattern;
                        
                        const sizeMultiplier = explosionPattern.includes('SPARKLE') ? 0.82 : 0.98;
                        this.baseSize = random(0.9, 2.3) * sizeMultiplier;
                        this.currentSize = this.baseSize;
                        
                        this.isFireSpark = true;
                        this.fireSparkDuration = random(0.12, 0.32);
                        this.life = 1.0;
                        this.decayRate = random(0.13, 0.36);
                        
                        this.verticalWeight = random(0.55, 1.1);
                        this.horizontalDrag = AIR_RESISTANCE;
                        this.verticalDrag = AIR_RESISTANCE;
                        
                        this.setupExplosionPattern(explosionPattern, explosionPower);
                        
                        this.colorMixRatio = 0;
                        this.colorMixSpeed = random(0.65, 1.2);
                        
                        this.hueShift = random(-14, 14);
                        this.originalHue = colorConfig.hue;
                        
                        this.sparkleFactor = explosionPattern.includes('SPARKLE') ? random(0.1, 0.26) : 0;
                        this.sparklePhase = random(0, Math.PI * 2);
                        
                        this.secondaryExplosionChance = isMobile ? 0.01 : 0.02;
                        
                        this.createdAt = Date.now();
                        
                        this.useSecondColor = colorConfig.type === 'dual' && Math.random() > 0.5;
                        this.fadeFactor = 1.5;
                    }
                    
                    setupExplosionPattern(pattern, power) {
                        const baseSpeed = random(185, 350) * power;
                        
                        switch(pattern) {
                            case EXPLOSION_PATTERNS.CIRCLE:
                                const angle = random(0, Math.PI * 2);
                                this.vx = Math.cos(angle) * baseSpeed;
                                this.vy = Math.sin(angle) * baseSpeed;
                                break;
                                
                            case EXPLOSION_PATTERNS.SPARKLE:
                                const sparkleAngle = random(0, Math.PI * 2);
                                this.vx = Math.cos(sparkleAngle) * baseSpeed * 0.65;
                                this.vy = Math.sin(sparkleAngle) * baseSpeed * 0.65;
                                break;
                                
                            case EXPLOSION_PATTERNS.VORTEX:
                                const vortexAngle = random(0, Math.PI * 2);
                                this.vx = Math.cos(vortexAngle) * baseSpeed * 0.55;
                                this.vy = Math.sin(vortexAngle) * baseSpeed * 0.55;
                                this.vortexFactor = random(2.5, 5.5);
                                break;
                                
                            case EXPLOSION_PATTERNS.RAINBOW:
                                const rainbowAngle = random(0, Math.PI * 2);
                                this.vx = Math.cos(rainbowAngle) * baseSpeed;
                                this.vy = Math.sin(rainbowAngle) * baseSpeed;
                                this.rainbowHue = (Date.now() * 0.007 + random(0, 360)) % 360;
                                break;
                                
                            case EXPLOSION_PATTERNS.ELLIPSE:
                                const ellipseAngle = random(0, Math.PI * 2);
                                const ellipseFactor = random(0.35, 0.65);
                                this.vx = Math.cos(ellipseAngle) * baseSpeed;
                                this.vy = Math.sin(ellipseAngle) * baseSpeed * ellipseFactor;
                                break;
                                
                            case EXPLOSION_PATTERNS.PARAMETRIC_CIRCLE:
                                const circleTheta = random(0, Math.PI * 2);
                                const circleRadius = baseSpeed * random(0.8, 1.2);
                                this.vx = Math.cos(circleTheta) * circleRadius;
                                this.vy = Math.sin(circleTheta) * circleRadius;
                                this.isParametricCircle = true;
                                this.parametricTheta = circleTheta;
                                break;
                                
                            case EXPLOSION_PATTERNS.PARAMETRIC_ELLIPSE:
                                const ellipseTheta = random(0, Math.PI * 2);
                                const a = baseSpeed * random(1.0, 1.5);
                                const b = baseSpeed * random(0.5, 1.0);
                                this.vx = Math.cos(ellipseTheta) * a;
                                this.vy = Math.sin(ellipseTheta) * b;
                                this.isParametricEllipse = true;
                                this.parametricTheta = ellipseTheta;
                                this.a = a;
                                this.b = b;
                                break;
                                
                            case EXPLOSION_PATTERNS.PARAMETRIC_STAR:
                                const starTheta = random(0, Math.PI * 2);
                                const starSize = baseSpeed * random(0.7, 1.3);
                                const cos3 = Math.pow(Math.cos(starTheta), 3);
                                const sin3 = Math.pow(Math.sin(starTheta), 3);
                                this.vx = cos3 * starSize;
                                this.vy = sin3 * starSize;
                                this.isParametricStar = true;
                                this.parametricTheta = starTheta;
                                this.starTwinkleSpeed = random(3.0, 5.0);
                                this.starTwinklePhase = random(0, Math.PI * 2);
                                break;
                                
                            default:
                                const normalAngle = random(0, Math.PI * 2);
                                this.vx = Math.cos(normalAngle) * baseSpeed;
                                this.vy = Math.sin(normalAngle) * baseSpeed;
                                break;
                        }
                        
                        if (!pattern.includes('PARAMETRIC')) {
                            this.vx += random(-35, 35);
                            this.vy += random(-35, 35);
                        }
                    }
                    
                    update(deltaTime) {
                        const deltaSeconds = deltaTime / 1000;
                        
                        if (this.isParametricCircle || this.isParametricEllipse || this.isParametricStar) {
                            this.parametricTheta += deltaSeconds * 1.5;
                            
                            if (this.isParametricCircle) {
                                const radius = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                                this.vx = Math.cos(this.parametricTheta) * radius;
                                this.vy = Math.sin(this.parametricTheta) * radius;
                            } else if (this.isParametricEllipse) {
                                this.vx = Math.cos(this.parametricTheta) * this.a;
                                this.vy = Math.sin(this.parametricTheta) * this.b;
                            } else if (this.isParametricStar) {
                                const cos3 = Math.pow(Math.cos(this.parametricTheta), 3);
                                const sin3 = Math.pow(Math.sin(this.parametricTheta), 3);
                                const starSize = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                                this.vx = cos3 * starSize;
                                this.vy = sin3 * starSize;
                                
                                this.currentSize = this.baseSize * (1 + Math.sin(Date.now() * 0.001 * this.starTwinkleSpeed + this.starTwinklePhase) * 0.3);
                            }
                        }
                        
                        this.x += this.vx * deltaSeconds;
                        this.y += this.vy * deltaSeconds;
                        
                        this.vy += GRAVITY * this.verticalWeight * deltaSeconds;
                        this.vx += WIND * random(-0.016, 0.016) * deltaSeconds;
                        
                        this.vx *= Math.pow(this.horizontalDrag, deltaSeconds * 60);
                        this.vy *= Math.pow(this.verticalDrag, deltaSeconds * 60);
                        
                        this.life -= this.decayRate * deltaSeconds;
                        
                        const aliveTime = (Date.now() - this.createdAt) / 1000;
                        if (this.isFireSpark && aliveTime > this.fireSparkDuration) {
                            this.isFireSpark = false;
                        }
                        
                        if (!this.isFireSpark && this.colorMixRatio < 1) {
                            this.colorMixRatio = Math.min(1, this.colorMixRatio + this.colorMixSpeed * deltaSeconds);
                        }
                        
                        this.currentSize = this.baseSize * this.life;
                        
                        if (this.explosionPattern === EXPLOSION_PATTERNS.VORTEX) {
                            const spiralTime = Date.now() * 0.001;
                            this.vx += Math.cos(spiralTime + this.x * 0.01) * this.vortexFactor;
                            this.vy += Math.sin(spiralTime + this.y * 0.01) * this.vortexFactor;
                        }
                        
                        if (this.sparkleFactor > 0) {
                            this.currentSize *= 1 + Math.sin(Date.now() * 0.006 + this.sparklePhase) * this.sparkleFactor;
                        }
                        
                        if (this.explosionPattern === EXPLOSION_PATTERNS.RAINBOW) {
                            this.rainbowHue = (this.rainbowHue + deltaSeconds * 110) % 360;
                        }
                        
                        if (this.currentSize > 4.5 && Math.random() < this.secondaryExplosionChance * deltaSeconds * 60) {
                            this.createSecondaryExplosion();
                        }
                        
                        return this.life > 0 && this.y < canvas.height + 90;
                    }
                    
                    createSecondaryExplosion() {
                        const secondaryCount = isMobile ? randomInt(2, 8) : randomInt(4, 12);
                        for (let i = 0; i < secondaryCount; i++) {
                            const secondaryParticle = new Particle(
                                this.x,
                                this.y,
                                this.colorConfig,
                                this.explosionPower * 0.25,
                                'sparkle'
                            );
                            secondaryParticle.baseSize = random(0.4, 1.3);
                            secondaryParticle.decayRate = random(0.25, 0.55);
                            particles.push(secondaryParticle);
                        }
                    }
                    
                    draw(ctx) {
                        const alpha = Math.max(0, 1 - (1 - this.life) * this.fadeFactor);
                        
                        let color;
                        if (this.isFireSpark) {
                            const brightness = 88 + Math.sin(Date.now() * 0.0035) * 7;
                            color = `hsla(60, 100%, ${brightness}%, ${alpha * 0.88})`;
                        } else {
                            let hue, saturation, lightness;
                            
                            if (this.explosionPattern === EXPLOSION_PATTERNS.RAINBOW) {
                                hue = this.rainbowHue;
                                saturation = 100;
                                lightness = 72;
                            } else if (this.colorConfig.type === 'dual' && this.useSecondColor) {
                                hue = this.colorConfig.secondHue;
                                saturation = this.colorConfig.secondSaturation;
                                lightness = this.colorConfig.secondLightness;
                            } else {
                                hue = (this.originalHue + this.hueShift * this.colorMixRatio) % 360;
                                saturation = this.colorConfig.saturation;
                                lightness = this.colorConfig.lightness;
                            }
                            
                            const mixedHue = hue;
                            const mixedSaturation = saturation * this.colorMixRatio;
                            const mixedLightness = 68 + (lightness - 68) * this.colorMixRatio;
                            
                            color = `hsla(${mixedHue}, ${mixedSaturation}%, ${mixedLightness}%, ${alpha * 0.82})`;
                        }
                        
                        ctx.fillStyle = color;
                        
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.currentSize, 0, Math.PI * 2);
                        ctx.fill();
                        
                        if (this.life > 0.5) {
                            ctx.globalAlpha = this.life * 0.28;
                            ctx.fillStyle = this.isFireSpark ? 'rgba(255, 255, 235, 0.45)' : `hsla(${this.colorConfig.hue}, 62%, 78%, 0.28)`;
                            ctx.beginPath();
                            ctx.arc(this.x, this.y, this.currentSize * 1.18, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.globalAlpha = 1.0;
                        }
                    }
                }
                
                // 烟花类
                class Firework {
                    constructor(x, targetY, colorConfig) {
                        this.x = x;
                        this.y = canvas.height;
                        this.targetY = targetY;
                        this.colorConfig = colorConfig;
                        
                        this.speed = random(380, 620);
                        
                        this.exploded = false;
                        this.explosionPower = random(1.25, 2.1);
                        this.explosionPattern = getRandomExplosionPattern();
                        
                        this.lineLength = random(11, 28);
                        this.lineWidth = 1.1;
                        this.lineColor = `hsla(60, 100%, 82%, 0.55)`;
                        
                        this.createdAt = Date.now();
                        
                        this.explosionCount = 0;
                        this.maxExplosions = isMobile ? randomInt(2, 4) : randomInt(3, 6);
                        
                        this.playLaunchSound();
                    }
                    
                    playLaunchSound() {
                        try {
                            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                            const oscillator = audioContext.createOscillator();
                            const gainNode = audioContext.createGain();
                            
                            oscillator.connect(gainNode);
                            gainNode.connect(audioContext.destination);
                            
                            oscillator.type = 'sine';
                            oscillator.frequency.setValueAtTime(370, audioContext.currentTime);
                            oscillator.frequency.exponentialRampToValueAtTime(650, audioContext.currentTime + 0.26);
                            
                            gainNode.gain.setValueAtTime(0.09, audioContext.currentTime);
                            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.31);
                            
                            oscillator.start(audioContext.currentTime);
                            oscillator.stop(audioContext.currentTime + 0.31);
                        } catch (error) {}
                    }
                    
                    update(deltaTime) {
                        if (!this.exploded) {
                            const deltaSeconds = deltaTime / 1000;
                            
                            this.y -= this.speed * deltaSeconds;
                            
                            if (this.y <= this.targetY) {
                                this.explode();
                                return false;
                            }
                            
                            return true;
                        }
                        
                        return false;
                    }
                    
                    explode() {
                        this.exploded = true;
                        this.explosionCount++;
                        
                        const powerMultiplier = isMobile ? 1.0 : 1.2;
                        this.createExplosion(this.x, this.y, this.explosionPower * powerMultiplier, this.explosionPattern);
                        
                        if (this.explosionCount < this.maxExplosions) {
                            const nextExplosionDelay = isMobile ? random(150, 400) : random(120, 350);
                            setTimeout(() => {
                                this.createSubsequentExplosion();
                            }, nextExplosionDelay);
                        }
                    }
                    
                    createSubsequentExplosion() {
                        this.explosionCount++;
                        
                        const distance = random(70, 185);
                        const angle = random(0, Math.PI * 2);
                        
                        const newX = this.x + Math.cos(angle) * distance;
                        const newY = this.y + Math.sin(angle) * distance;
                        
                        const subExplosionPower = this.explosionPower * (isMobile ? random(0.5, 0.8) : random(0.6, 0.9));
                        
                        this.createExplosion(newX, newY, subExplosionPower, this.explosionPattern);
                        
                        if (this.explosionCount < this.maxExplosions) {
                            const nextExplosionDelay = isMobile ? random(150, 400) : random(120, 350);
                            setTimeout(() => {
                                this.createSubsequentExplosion();
                            }, nextExplosionDelay);
                        } else if (!isMobile && Math.random() < 0.3 && this.explosionCount < this.maxExplosions + 2) {
                            const extraDelay = random(150, 400);
                            setTimeout(() => {
                                this.createSubsequentExplosion();
                            }, extraDelay);
                            this.maxExplosions += randomInt(1, 2);
                        }
                    }
                    
                    createExplosion(x, y, power, pattern) {
                        if (pattern === EXPLOSION_PATTERNS.HEART) {
                            heartExplosions.push(new HeartExplosionManager(x, y, this.colorConfig, power));
                            return;
                        }
                        
                        if (pattern === EXPLOSION_PATTERNS.METEOR_SHOWER) {
                            this.createMeteorShower(x, y, power);
                            return;
                        }
                        
                        if (pattern === EXPLOSION_PATTERNS.FIRE_TREE) {
                            this.createFireTree(x, y, power);
                            return;
                        }
                        
                        if (pattern === EXPLOSION_PATTERNS.CHRYSANTHEMUM) {
                            this.createChrysanthemum(x, y, power);
                            return;
                        }
                        
                        if (pattern === EXPLOSION_PATTERNS.SPIRAL_PARAMETRIC) {
                            this.createParametricSpiral(x, y, power);
                            return;
                        }
                        
                        this.createNormalExplosion(x, y, power, pattern);
                    }
                    
                    createParametricSpiral(x, y, power) {
                        const baseParticleCount = isMobile ? randomInt(40, 70) : randomInt(60, 100);
                        const particleCount = Math.floor(baseParticleCount * particleMultiplier);
                        
                        for (let i = 0; i < particleCount; i++) {
                            particles.push(new ParametricSpiralParticle(
                                x,
                                y,
                                this.colorConfig,
                                power
                            ));
                        }
                        
                        const baseCenterCount = isMobile ? randomInt(12, 25) : randomInt(20, 40);
                        const centerCount = Math.floor(baseCenterCount * particleMultiplier);
                        for (let i = 0; i < centerCount; i++) {
                            const angle = random(0, Math.PI * 2);
                            const speed = random(80, 180) * power;
                            const spark = new Particle(
                                x,
                                y,
                                this.colorConfig,
                                power * 0.6,
                                'sparkle'
                            );
                            spark.vx = Math.cos(angle) * speed;
                            spark.vy = Math.sin(angle) * speed;
                            spark.baseSize = random(0.8, 1.8);
                            spark.decayRate = random(0.25, 0.45);
                            particles.push(spark);
                        }
                    }
                    
                    createMeteorShower(x, y, power) {
                        const baseMeteorCount = isMobile ? randomInt(6, 12) : randomInt(9, 16);
                        const meteorCount = Math.floor(baseMeteorCount * particleMultiplier);
                        
                        for (let i = 0; i < meteorCount; i++) {
                            const meteor = new Meteor(
                                x + random(-32, 32),
                                y + random(-32, 32),
                                this.colorConfig
                            );
                            meteor.speed *= power;
                            particles.push(meteor);
                        }
                        
                        const baseSparkCount = isMobile ? randomInt(15, 30) : randomInt(22, 45);
                        const sparkCount = Math.floor(baseSparkCount * particleMultiplier);
                        for (let i = 0; i < sparkCount; i++) {
                            const spark = new Particle(
                                x + random(-45, 45),
                                y + random(-45, 45),
                                this.colorConfig,
                                power * 0.45,
                                'sparkle'
                            );
                            spark.baseSize = random(0.4, 1.4);
                            spark.decayRate = random(0.18, 0.38);
                            particles.push(spark);
                        }
                    }
                    
                    createFireTree(x, y, power) {
                        const baseTreeCount = isMobile ? randomInt(30, 50) : randomInt(45, 75);
                        const treeCount = Math.floor(baseTreeCount * particleMultiplier);
                        
                        for (let i = 0; i < treeCount; i++) {
                            const fireTreeParticle = new FireTreeParticle(
                                x + random(-22, 22),
                                y + random(-22, 22),
                                this.colorConfig
                            );
                            fireTreeParticle.baseSize *= power * 0.85;
                            fireTreeParticle.fallSpeed *= power;
                            particles.push(fireTreeParticle);
                        }
                        
                        const baseSparkCount = isMobile ? randomInt(15, 30) : randomInt(25, 45);
                        const sparkCount = Math.floor(baseSparkCount * particleMultiplier);
                        for (let i = 0; i < sparkCount; i++) {
                            const spark = new Particle(
                                x + random(-32, 32),
                                y + random(-32, 32),
                                this.colorConfig,
                                power * 0.55,
                                'sparkle'
                            );
                            spark.baseSize = random(0.9, 2.0);
                            spark.decayRate = random(0.28, 0.55);
                            spark.sparkleFactor = random(0.35, 0.65);
                            particles.push(spark);
                        }
                    }
                    
                    createChrysanthemum(x, y, power) {
                        const baseParticleCount = isMobile ? randomInt(70, 110) : randomInt(110, 170);
                        const particleCount = Math.floor(baseParticleCount * particleMultiplier);
                        
                        for (let i = 0; i < particleCount; i++) {
                            particles.push(new ChrysanthemumParticle(
                                x,
                                y,
                                this.colorConfig,
                                power
                            ));
                        }
                        
                        const sparkCount = Math.floor(particleCount * (isMobile ? 0.25 : 0.35));
                        for (let i = 0; i < sparkCount; i++) {
                            const spark = new ChrysanthemumParticle(
                                x + random(-13, 13),
                                y + random(-13, 13),
                                this.colorConfig,
                                power * 0.65
                            );
                            spark.baseSize = random(0.4, 1.6);
                            spark.decayRate = random(0.22, 0.45);
                            particles.push(spark);
                        }
                    }
                    
                    createNormalExplosion(x, y, power, pattern) {
                        const baseParticleCount = this.getParticleCountByPattern(pattern);
                        const particleCount = Math.floor(baseParticleCount * particleMultiplier);
                        
                        for (let i = 0; i < particleCount; i++) {
                            particles.push(new Particle(
                                x,
                                y,
                                this.colorConfig,
                                power,
                                pattern
                            ));
                        }
                        
                        const sparkCount = Math.floor(particleCount * (isMobile ? 0.25 : 0.35));
                        for (let i = 0; i < sparkCount; i++) {
                            const spark = new Particle(
                                x + random(-14, 14),
                                y + random(-14, 14),
                                this.colorConfig,
                                power * 0.65,
                                pattern === EXPLOSION_PATTERNS.SPARKLE ? pattern : 'sparkle'
                            );
                            spark.baseSize = random(0.4, 1.6);
                            spark.decayRate = random(0.22, 0.42);
                            particles.push(spark);
                        }
                    }
                    
                    getParticleCountByPattern(pattern) {
                        const mobileFactor = isMobile ? 0.7 : 1;
                        
                        switch(pattern) {
                            case EXPLOSION_PATTERNS.CIRCLE:
                                return Math.floor(randomInt(85, 130) * mobileFactor);
                            case EXPLOSION_PATTERNS.SPARKLE:
                                return Math.floor(randomInt(95, 150) * mobileFactor);
                            case EXPLOSION_PATTERNS.VORTEX:
                                return Math.floor(randomInt(90, 140) * mobileFactor);
                            case EXPLOSION_PATTERNS.RAINBOW:
                                return Math.floor(randomInt(115, 170) * mobileFactor);
                            case EXPLOSION_PATTERNS.ELLIPSE:
                                return Math.floor(randomInt(65, 115) * mobileFactor);
                            case EXPLOSION_PATTERNS.PARAMETRIC_CIRCLE:
                                return Math.floor(randomInt(100, 150) * mobileFactor);
                            case EXPLOSION_PATTERNS.PARAMETRIC_ELLIPSE:
                                return Math.floor(randomInt(80, 130) * mobileFactor);
                            case EXPLOSION_PATTERNS.PARAMETRIC_STAR:
                                return Math.floor(randomInt(120, 180) * mobileFactor);
                            case EXPLOSION_PATTERNS.SPIRAL_PARAMETRIC:
                                return Math.floor(randomInt(60, 100) * mobileFactor);
                            default:
                                return Math.floor(randomInt(65, 115) * mobileFactor);
                        }
                    }
                    
                    draw(ctx) {
                        if (!this.exploded) {
                            const lineEndY = this.y + this.lineLength;
                            if (lineEndY < canvas.height) {
                                ctx.strokeStyle = this.lineColor;
                                ctx.lineWidth = this.lineWidth;
                                ctx.beginPath();
                                ctx.moveTo(this.x, lineEndY);
                                ctx.lineTo(this.x, this.y);
                                ctx.stroke();
                            }
                            
                            ctx.fillStyle = 'hsla(60, 100%, 87%, 0.85)';
                            ctx.beginPath();
                            ctx.arc(this.x, this.y, 2.0, 0, Math.PI * 2);
                            ctx.fill();
                            
                            ctx.globalAlpha = 0.38;
                            ctx.fillStyle = 'hsla(60, 100%, 82%, 0.45)';
                            ctx.beginPath();
                            ctx.arc(this.x, this.y, 3.2, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.globalAlpha = 1.0;
                        }
                    }
                }
                
                // 烟花创建函数
                function createRandomFirework() {
                    if (Math.random() < 0.22) return;
                    
                    const x = random(50, canvas.width - 50);
                    const targetY = random(canvas.height * 0.2, canvas.height * EXPLOSION_HEIGHT_RATIO);
                    const colorConfig = getRandomColorConfig();
                    
                    fireworks.push(new Firework(x, targetY, colorConfig));
                }
                
                // 创建特殊烟花
                function createSpecialFirework() {
                    if (isMobile && Math.random() < 0.7) return;
                    if (!isMobile && Math.random() < 0.5) return;
                    
                    const x = random(100, canvas.width - 100);
                    const targetY = random(canvas.height * 0.15, canvas.height * 0.32);
                    const colorConfig = getRandomColorConfig();
                    
                    const specialFirework = new Firework(x, targetY, colorConfig);
                    specialFirework.explosionPower *= isMobile ? 1.2 : 1.45;
                    specialFirework.maxExplosions = isMobile ? randomInt(3, 5) : randomInt(4, 8);
                    fireworks.push(specialFirework);
                }
                
                // 自动发射系统
                function startAutoFire() {
                    if (isAutoFiring) return;
                    
                    isAutoFiring = true;
                    
                    // 初始发射烟花数量根据设备调整
                    setTimeout(() => createRandomFirework(), 300);
                    setTimeout(() => createRandomFirework(), 600);
                    if (!isMobile || Math.random() > 0.5) {
                        setTimeout(() => createSpecialFirework(), 900);
                    }
                    setTimeout(() => createRandomFirework(), 1200);
                    setTimeout(() => createRandomFirework(), 1500);
                    
                    autoFireInterval = setInterval(() => {
                        const now = Date.now();
                        const fireworkInterval = isMobile ? 1100 : 900;
                        if (now - lastFireworkTime > fireworkInterval) {
                            let count;
                            if (isMobile) {
                                count = Math.random() > 0.6 ? 2 : 1;
                            } else {
                                count = Math.random() > 0.3 ? 3 : (Math.random() > 0.5 ? 2 : 1);
                            }
                            
                            for (let i = 0; i < count; i++) {
                                setTimeout(() => {
                                    if (isMobile) {
                                        if (Math.random() > 0.8) {
                                            createSpecialFirework();
                                        } else {
                                            createRandomFirework();
                                        }
                                    } else {
                                        if (Math.random() > 0.6) {
                                            createSpecialFirework();
                                        } else {
                                            createRandomFirework();
                                        }
                                    }
                                }, i * (isMobile ? 150 : 120));
                            }
                            lastFireworkTime = now;
                        }
                    }, isMobile ? 1100 : 900);
                }
                
                // 动画循环
                function animate(currentTime) {
                    const deltaTime = currentTime - lastTime || 0;
                    lastTime = currentTime;
                    
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.11)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    for (let i = fireworks.length - 1; i >= 0; i--) {
                        const firework = fireworks[i];
                        if (!firework.update(deltaTime)) {
                            fireworks.splice(i, 1);
                        } else {
                            firework.draw(ctx);
                        }
                    }
                    
                    for (let i = heartExplosions.length - 1; i >= 0; i--) {
                        if (!heartExplosions[i].update(deltaTime)) {
                            heartExplosions.splice(i, 1);
                        } else {
                            heartExplosions[i].draw(ctx);
                        }
                    }
                    
                    for (let i = particles.length - 1; i >= 0; i--) {
                        const particle = particles[i];
                        if (!particle.update(deltaTime)) {
                            particles.splice(i, 1);
                        } else {
                            particle.draw(ctx);
                        }
                    }
                    
                    const maxParticles = isMobile ? 1500 : 2200;
                    const keepParticles = isMobile ? 1300 : 1900;
                    if (particles.length > maxParticles) {
                        particles.splice(0, particles.length - keepParticles);
                    }
                    
                    if (fireworks.length > (isMobile ? 8 : 12)) {
                        fireworks.splice(0, fireworks.length - (isMobile ? 6 : 10));
                    }
                    
                    if (heartExplosions.length > (isMobile ? 3 : 4)) {
                        heartExplosions.splice(0, heartExplosions.length - (isMobile ? 2 : 3));
                    }
                    
                    fireworksAnimationId = requestAnimationFrame(animate);
                }
                
                // 页面可见性API
                let isPageVisible = true;
                
                document.addEventListener('visibilitychange', function() {
                    isPageVisible = !document.hidden;
                    
                    if (!isPageVisible) {
                        if (fireworksAnimationId) {
                            cancelAnimationFrame(fireworksAnimationId);
                            fireworksAnimationId = null;
                        }
                        if (bgMusic) {
                            bgMusic.pause();
                        }
                    } else {
                        if (!fireworksAnimationId) {
                            lastTime = performance.now();
                            animate(lastTime);
                        }
                        if (bgMusic.paused && musicPlayed) {
                            bgMusic.play().catch(() => {});
                        }
                    }
                });
                
                // 初始化烟花系统
                function initFireworksSystem() {
                    lastTime = performance.now();
                    animate(lastTime);
                    
                    startAutoFire();
                }
                
                initFireworksSystem();
                
                // 返回烟花系统控制函数
                return {
                    stop: function() {
                        if (fireworksAnimationId) {
                            cancelAnimationFrame(fireworksAnimationId);
                            fireworksAnimationId = null;
                        }
                        if (autoFireInterval) {
                            clearInterval(autoFireInterval);
                            autoFireInterval = null;
                        }
                        if (bgMusic) {
                            bgMusic.pause();
                        }
                        isAutoFiring = false;
                        
                        // 清空所有粒子
                        fireworks = [];
                        particles = [];
                        heartExplosions = [];
                    }
                };
            }
            
            // 返回第一页
            function goBackToPage1() {
                // 停止烟花系统
                if (fireworksSystem) {
                    fireworksSystem.stop();
                    fireworksSystem = null;
                }
                
                // 暂停音乐
                if (bgMusic) {
                    bgMusic.pause();
                    bgMusic.currentTime = 0;
                }
                
                // 重置音乐播放状态
                musicPlayed = false;
                
                // 隐藏第三页
                page3.classList.remove('active');
                
                // 隐藏第二页
                page2.classList.remove('active');
                
                // 显示第一页
                setTimeout(() => {
                    page1.classList.remove('hidden');
                    
                    // 清空输入框
                    nameInput.value = '';
                    
                    // 清空名字显示区域
                    nameDisplay.innerHTML = '';
                    
                    // 清空第三页显示区域
                    greetingContainer.style.display = 'flex';
                    greetingContainer.classList.remove('active');
                    greetingContainer.classList.remove('fade-out');
                    friendName.textContent = '';
                    statementDisplay.classList.remove('active');
                    statementContent.innerHTML = '';
                    
                    // 重新聚焦到输入框
                    nameInput.focus();
                }, 500);
            }
            
            // 提交按钮点击事件
            submitBtn.addEventListener('click', submitName);
            
            // 输入框回车事件
            nameInput.addEventListener('keyup', function(event) {
                if (event.key === 'Enter') {
                    submitName();
                }
            });
            
            // 对话气泡点击效果
            const dialogueBoxes = document.querySelectorAll('.dialogue-box');
            dialogueBoxes.forEach(box => {
                box.addEventListener('click', function() {
                    this.classList.toggle('pulse');
                });
            });
            
            // 添加键盘快捷键支持
            document.addEventListener('keydown', function(event) {
                // 按空格键切换背景
                if (event.key === ' ' && !page1.classList.contains('hidden')) {
                    document.body.style.background = document.body.style.background.includes('c3cfe2') 
                        ? "linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%)" 
                        : "linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%)";
                    event.preventDefault();
                }
                
                // 按ESC键返回第一页
                if (event.key === 'Escape' && 
                    (page2.classList.contains('active') || page3.classList.contains('active'))) {
                    goBackToPage1();
                }
            });
            
            // 初始聚焦到输入框
            nameInput.focus();
            
            // 添加页面加载动画
            document.body.style.opacity = 0;
            setTimeout(() => {
                document.body.style.transition = 'opacity 0.5s ease';
                document.body.style.opacity = 1;
            }, 100);
            
            // 触摸事件处理
            document.addEventListener('touchmove', function(e) {
                e.preventDefault();
            }, { passive: false });
            
            // 页面加载时预加载音乐
            window.addEventListener('load', function() {
                // 预加载音乐
                try {
                    bgMusic.load();
                    console.log("音乐预加载完成");
                } catch (error) {
                    console.log("音乐预加载失败:", error);
                }
            });
        });
    </script>
</body>
</html>
